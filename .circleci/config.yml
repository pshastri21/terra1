# Orb 'circleci/aws-ecr@6.12.2' resolved to 'circleci/aws-ecr@6.12.2'
# Orb 'circleci/windows@2.4.0' resolved to 'circleci/windows@2.4.0'
# Orb 'circleci/aws-ecs@1.3.0' resolved to 'circleci/aws-ecs@1.3.0'
# Orb 'cloudradar-monitoring/ms-teams@0.0.1' resolved to 'cloudradar-monitoring/ms-teams@0.0.1'
# Orb 'circleci/aws-cli@1.3.1' resolved to 'circleci/aws-cli@1.3.1'
# Orb 'circleci/slack@4.3.0' resolved to 'circleci/slack@4.3.0'
version: 2
jobs:
  build_and_push_staging:
    machine: true
    steps:
    - checkout
    - run:
        name: Pull Submodules for Development
        command: |
          git submodule init
          git submodule update --remote
          cd eldmandate-data-layer
          git config --global user.email "circle@circle"
          git config --global user.name "circleci"
          git checkout master
          git pull origin master
          cd ..
    - checkout
    - run:
        command: |
          AWS_VER_REGEXP_2='aws-cli\/2.\d*.\d*'
          AWS_VER_REGEXP_1='aws-cli\/1.\d*.\d*'
          # initialize installed version to zero, to signify not installed (Or we want to ignore the installed version and re-install).
          AWS_CLI_INSTALLED_VERSION="0"
          AWS_CLI_VERSION_SELECTED="2"

          if [[ $EUID == 0 ]]; then export SUDO=""; else export SUDO="sudo"; fi

          if [ "false" == "false" ]; then
              if ! command -v aws --version >/dev/null 2>&1  ; then
                  echo AWS is not installed
              else
                  echo AWS is currently installed.
                  if aws --version 2>&1 | grep -q $AWS_VER_REGEXP_2; then
                      echo AWS CLI v2 is installed
                      AWS_CLI_INSTALLED_VERSION="2"
                  fi
                  if aws --version 2>&1 | grep -q $AWS_VER_REGEXP_1; then
                      echo AWS CLI v1 is installed
                      AWS_CLI_INSTALLED_VERSION="1"
                  fi
              fi
          else
              echo "Skipping version check. Installing CLI"
          fi

          AWS_V2_UPDATE_PARAM=""
          if aws --version 2>&1 | grep -q $AWS_VER_REGEXP_2; then
              AWS_V2_UPDATE_PARAM="--update"
          fi

          #If the desired version of the CLI is not installed, install it.
          if [[ $AWS_CLI_VERSION_SELECTED != $AWS_CLI_INSTALLED_VERSION ]]; then

              #uninstall AWS CLI if it is installed.
              if which aws; then
                  echo Uninstalling old CLI
                  $SUDO rm -rf $(which aws)
              fi
              case $AWS_CLI_VERSION_SELECTED in
                  "1")
                      if ! command -v python >/dev/null 2>&1 && ! command -v python3 >/dev/null 2>&1 ; then
                          echo "Your environment does not seem to have Python installed, a requirement of the AWS CLI."
                          echo "Please either utilize the AWS CLI v2, or select an envionment with Python installed."
                          echo "Recommended image: cimg:/python:3.8"
                          exit 1
                      fi
                      # install CLI v1
                      export PIP=$(which pip pip3 | head -1)
                      if [[ -n $PIP ]]; then
                          if which sudo > /dev/null; then
                              sudo $PIP install awscli --upgrade
                          else
                              # This installs the AWS CLI to ~/.local/bin. Make sure that ~/.local/bin is in your $PATH.
                              $PIP install awscli --upgrade --user
                          fi
                      elif [[ $(which unzip curl | wc -l) -eq 2 ]]; then
                          cd
                          curl "https://s3.amazonaws.com/aws-cli/awscli-bundle.zip" -o "awscli-bundle.zip"
                          unzip awscli-bundle.zip
                          if which sudo > /dev/null; then
                              sudo ~/awscli-bundle/install -i /usr/local/aws -b /usr/local/bin/aws
                          else
                              # This installs the AWS CLI to the default location (~/.local/lib/aws) and create a symbolic link (symlink) at ~/bin/aws. Make sure that ~/bin is in your $PATH.
                              awscli-bundle/install -b ~/bin/aws
                          fi
                          rm -rf awscli-bundle*
                          cd -
                      else
                          echo "Unable to install AWS CLI. Please install pip."
                          exit 1
                      fi
                      # Installation check
                      if aws --version &> grep -q "aws-cli/1"; then
                          echo "AWS CLI V1 has been installed successfully"
                          exit 0
                      else
                          echo "There was an issue installing the AWS CLI V1. Exiting."
                          exit 1
                      fi
                  ;;
                  "2")
                      # install CLI v2

                      cd /tmp || exit

                      # PLATFORM CHECK: mac vs. alpine vs. other linux
                      if uname -a | grep Darwin; then
                          SYS_ENV_PLATFORM=darwin
                      elif uname -a | grep Linux; then
                          SYS_ENV_PLATFORM=linux
                      else
                          echo "This platform appears to be unsupported."
                          uname -a
                          exit 1
                      fi

                      case $SYS_ENV_PLATFORM in
                          linux)
                              curl -sSL "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
                              unzip awscliv2.zip
                              $SUDO ./aws/install $AWS_V2_UPDATE_PARAM
                              rm awscliv2.zip
                              ;;
                          darwin)
                              curl -sSL "https://awscli.amazonaws.com/AWSCLIV2.pkg" -o "AWSCLIV2.pkg"
                              $SUDO installer -pkg AWSCLIV2.pkg -target /
                              rm AWSCLIV2.pkg
                              ;;
                          *)
                              echo "This orb does not currently support your platform. If you believe it should, please consider opening an issue on the GitHub repository:"
                              echo "https://github.com/CircleCI-Public/aws-cli-orb/issues/new"
                              exit 1
                          ;;
                      esac
                      # Installation check
                      if aws --version &> grep -q "aws-cli/2"; then
                          echo "AWS CLI V2 has been installed successfully"
                          exit 0
                      else
                          echo "There was an issue installing the AWS CLI V2. Exiting."
                          exit 1
                      fi
                  ;;
              esac

          else
              echo "The v${AWS_CLI_VERSION_SELECTED} AWS CLI is already installed."
              exit 0
          fi
        name: Install AWS CLI v2
    - run:
        command: |
          if [ -z "${AWS_PAGER}" ]; then
            echo 'export AWS_PAGER=""' >> $BASH_ENV
            echo "AWS_PAGER is being set to the empty string to disable all output paging for AWS CLI commands."
            echo "You can set the 'disable-aws-pager' parameter to 'false' to disable this behavior."
          fi
        name: Disable AWS pager if not already configured
    - run:
        command: |
          aws configure set aws_access_key_id \
            $AWS_ACCESS_KEY_ID \
            --profile default
        name: Configure AWS Access Key ID
    - run:
        command: |
          aws configure set aws_secret_access_key \
            $AWS_SECRET_ACCESS_KEY \
            --profile default
        name: Configure AWS Secret Access Key
    - run:
        command: |
          aws configure set default.region $AWS_REGION \
            --profile default
        name: Configure AWS default region
    - run:
        command: |
          # get-login-password returns a password that we pipe to the docker login command
          aws ecr get-login-password --region $AWS_REGION --profile default | docker login --username AWS --password-stdin $AWS_ECR_ACCOUNT_URL
        name: Log into Amazon ECR
    - run:
        command: |
          registry_id=$(echo $AWS_ECR_ACCOUNT_URL | sed "s;\..*;;g")
          number_of_tags_in_ecr=0

          docker_tag_args=""
          IFS="," read -ra DOCKER_TAGS <<< "${CIRCLE_SHA1}"
          for tag in "${DOCKER_TAGS[@]}"; do
            if [ "false" = "true" ]; then
              docker_tag_exists_in_ecr=$(aws ecr describe-images --registry-id $registry_id --repository-name staging-assettracker-api-microservice --query "contains(imageDetails[].imageTags[], '$tag')")
              if [ "$docker_tag_exists_in_ecr" = "true" ]; then
                docker pull $AWS_ECR_ACCOUNT_URL/staging-assettracker-api-microservice:${tag}
                let "number_of_tags_in_ecr+=1"
              fi
            fi
            docker_tag_args="$docker_tag_args -t $AWS_ECR_ACCOUNT_URL/staging-assettracker-api-microservice:$tag"
          done
          if [ "false" = "false" ] || [ "false" = "true" -a $number_of_tags_in_ecr -lt ${#DOCKER_TAGS[@]} ]; then
            docker build \
               \
              -f ./Dockerfile \
              $docker_tag_args \
              .
          fi
        name: Build docker image
        no_output_timeout: 10m
    - run:
        command: |
          IFS="," read -ra DOCKER_TAGS <<< "${CIRCLE_SHA1}"
          for tag in "${DOCKER_TAGS[@]}"; do
            docker push $AWS_ECR_ACCOUNT_URL/staging-assettracker-api-microservice:${tag}
          done
        name: Push image to Amazon ECR
    - run:
        command: |
          echo 'export CCI_STATUS="fail"' > /tmp/SLACK_JOB_STATUS
        name: Slack - Detecting Job Status (FAIL)
        when: on_fail
    - run:
        command: |
          echo 'export CCI_STATUS="pass"' > /tmp/SLACK_JOB_STATUS
        name: Slack - Detecting Job Status (PASS)
        when: on_success
    - run:
        command: |
          BuildMessageBody() {
              # Send message
              #   If sending message, default to custom template,
              #   if none is supplied, check for a pre-selected template value.
              #   If none, error.
              if [ -n "$SLACK_PARAM_CUSTOM" ]; then
                  ModifyCustomTemplate
                  # shellcheck disable=SC2016
                  CUSTOM_BODY_MODIFIED=$(echo "$CUSTOM_BODY_MODIFIED" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed 's/`/\\`/g')
                  T2=$(eval echo \""$CUSTOM_BODY_MODIFIED"\")
              elif [ -n "$SLACK_PARAM_TEMPLATE" ]; then
                  TEMPLATE="\$$SLACK_PARAM_TEMPLATE"
                  T1=$(eval echo "$TEMPLATE" | sed 's/"/\\"/g')
                  T2=$(eval echo \""$T1"\")
              else
                  echo "Error: No message template selected."
                  echo "Select either a custom template or one of the pre-included ones via the 'custom' or 'template' parameters."
                  exit 1
              fi
              # Insert the default channel. THIS IS TEMPORARY
              T2=$(echo "$T2" | jq ". + {\"channel\": \"$SLACK_DEFAULT_CHANNEL\"}")
              SLACK_MSG_BODY=$T2
          }


          PostToSlack() {
              # Post once per channel listed by the channel parameter
              #    The channel must be modified in SLACK_MSG_BODY

              # shellcheck disable=SC2001
              for i in $(eval echo \""$SLACK_PARAM_CHANNEL"\" | sed "s/,/ /g")
              do
                  echo "Sending to Slack Channel: $i"
                  SLACK_MSG_BODY=$(echo "$SLACK_MSG_BODY" | jq --arg channel "$i" '.channel = $channel')
                  SLACK_SENT_RESPONSE=$(curl -s -f -X POST -H 'Content-type: application/json' -H "Authorization: Bearer $SLACK_ACCESS_TOKEN" --data "$SLACK_MSG_BODY" https://slack.com/api/chat.postMessage)
                  SLACK_ERROR_MSG=$(echo "$SLACK_SENT_RESPONSE" | jq '.error')
                  if [ ! "$SLACK_ERROR_MSG" = "null" ]; then
                      echo "Slack API returned an error message:"
                      echo "$SLACK_ERROR_MSG"
                      echo
                      echo
                      echo "View the Setup Guide: https://github.com/CircleCI-Public/slack-orb/wiki/Setup"
                      if [ "$SLACK_PARAM_IGNORE_ERRORS" = "0" ]; then
                          exit 1
                      fi
                  fi
              done
          }

          ModifyCustomTemplate() {
              # Inserts the required "text" field to the custom json template from block kit builder.
              if [ "$(echo "$SLACK_PARAM_CUSTOM" | jq '.text')" = "null" ]; then
                  CUSTOM_BODY_MODIFIED=$(echo "$SLACK_PARAM_CUSTOM" | jq '. + {"text": ""}')
              else
                  # In case the text field was set manually.
                  CUSTOM_BODY_MODIFIED=$(echo "$SLACK_PARAM_CUSTOM" | jq '.')
              fi
          }

          InstallJq() {
              if uname -a | grep Darwin > /dev/null 2>&1; then
                  echo "Checking For JQ + CURL: MacOS"
                  command -v jq >/dev/null 2>&1 || HOMEBREW_NO_AUTO_UPDATE=1 brew install jq --quiet
                  return $?

              elif cat /etc/issue | grep Debian > /dev/null 2>&1 || cat /etc/issue | grep Ubuntu > /dev/null 2>&1; then
                  echo "Checking For JQ + CURL: Debian"
                  if [ "$(id -u)" = 0 ]; then export SUDO=""; else # Check if we're root
                      export SUDO="sudo";
                  fi
                  command -v jq >/dev/null 2>&1 || { $SUDO apt -qq update && $SUDO apt -qq install -y jq; }
                  return $?

              elif cat /etc/issue | grep Alpine > /dev/null 2>&1; then
                  echo "Checking For JQ + CURL: Alpine"
                  command -v curl >/dev/null 2>&1 || { echo >&2 "SLACK ORB ERROR: CURL is required. Please install."; exit 1; }
                  command -v jq >/dev/null 2>&1 || { echo >&2 "SLACK ORB ERROR: JQ is required. Please install"; exit 1; }
                  return $?
              fi
          }

          FilterBy() {
              if [ -z "$1" ] || [ -z "$2" ]; then
                return
              fi

              # If any pattern supplied matches the current branch or the current tag, proceed; otherwise, exit with message.
              FLAG_MATCHES_FILTER="false"
              for i in $(echo "$1" | sed "s/,/ /g")
              do
                  if echo "$2" | grep -Eq "^${i}$"; then
                      FLAG_MATCHES_FILTER="true"
                      break
                  fi
              done
              if [ "$FLAG_MATCHES_FILTER" = "false" ]; then
                  # dont send message.
                  echo "NO SLACK ALERT"
                  echo
                  echo "Current reference \"$2\" does not match any matching parameter"
                  echo "Current matching pattern: $1"
                  exit 0
              fi
          }

          CheckEnvVars() {
              if [ -z "$SLACK_ACCESS_TOKEN" ]; then
                  echo "In order to use the Slack Orb (v4 +), an OAuth token must be present via the SLACK_ACCESS_TOKEN environment variable."
                  echo "Follow the setup guide available in the wiki: https://github.com/CircleCI-Public/slack-orb/wiki/Setup"
                  exit 1
              fi
              # If no channel is provided, quit with error
              if [ -z "$SLACK_PARAM_CHANNEL" ]; then
                 echo "No channel was provided. Enter value for SLACK_DEFAULT_CHANNEL env var, or channel parameter"
                 exit 1
              fi
              if [ -n "$SLACK_WEBHOOK" ]; then
                  echo "It appears you have a Slack Webhook token present in this job."
                  echo "Please note, Webhooks are no longer used for the Slack Orb (v4 +)."
                  echo "Follow the setup guide available in the wiki: https://github.com/CircleCI-Public/slack-orb/wiki/Setup"
              fi
          }

          ShouldPost() {
              if [ "$CCI_STATUS" = "$SLACK_PARAM_EVENT" ] || [ "$SLACK_PARAM_EVENT" = "always" ]; then
                  # In the event the Slack notification would be sent, first ensure it is allowed to trigger
                  # on this branch or this tag.
                  FilterBy "$SLACK_PARAM_BRANCHPATTERN" "$CIRCLE_BRANCH"
                  FilterBy "$SLACK_PARAM_TAGPATTERN" "$CIRCLE_TAG"

                  echo "Posting Status"
              else
                  # dont send message.
                  echo "NO SLACK ALERT"
                  echo
                  echo "This command is set to send an alert on: $SLACK_PARAM_EVENT"
                  echo "Current status: ${CCI_STATUS}"
                  exit 0
              fi
          }

          # Will not run if sourced from another script.
          # This is done so this script may be tested.
          ORB_TEST_ENV="bats-core"
          if [ "${0#*$ORB_TEST_ENV}" = "$0" ]; then
              CheckEnvVars
              . "/tmp/SLACK_JOB_STATUS"
              ShouldPost
              InstallJq
              BuildMessageBody
              PostToSlack

          fi
        environment:
          SLACK_PARAM_BRANCHPATTERN: .+
          SLACK_PARAM_CHANNEL: $SLACK_DEFAULT_CHANNEL
          SLACK_PARAM_CUSTOM: ''
          SLACK_PARAM_EVENT: fail
          SLACK_PARAM_IGNORE_ERRORS: true
          SLACK_PARAM_MENTIONS: ''
          SLACK_PARAM_TAGPATTERN: .+
          SLACK_PARAM_TEMPLATE: basic_fail_1
          basic_fail_1: "{\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"Job Failed. :red_circle:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Job*: ${CIRCLE_JOB}\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Branch*:\\\\n$CIRCLE_BRANCH\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Author*:\\\\n$CIRCLE_USERNAME\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Mentions*:\\\\n$SLACK_PARAM_MENTIONS\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Job\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"${CIRCLE_BUILD_URL}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}\n"
          basic_on_hold_1: "{\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"ON HOLD - Awaiting Approval :raised_hand:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Branch*:\\\\n$CIRCLE_BRANCH\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Author*:\\\\n$CIRCLE_USERNAME\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Mentions*:\\\\n$SLACK_PARAM_MENTIONS\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Workflow\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"https://circleci.com/workflow-run/${CIRCLE_WORKFLOW_ID}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}"
          basic_success_1: "{\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"Job Succeeded. :white_check_mark:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Job*: ${CIRCLE_JOB}\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Branch*:\\\\n$CIRCLE_BRANCH\"\n                },\n                {\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Commit*:\\\\n$CIRCLE_SHA1\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Author*:\\\\n$CIRCLE_USERNAME\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Job\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"${CIRCLE_BUILD_URL}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}\n"
          success_tagged_deploy_1: "{\n\t\"text\": \"\",\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"Deployment Successful! :tada:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*When*:\\\\n$(date +'%m/%d/%Y %T')\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Tag*:\\\\n$CIRCLE_TAG\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Job\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"${CIRCLE_BUILD_URL}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}"
        name: Slack - Sending Notification
        when: always
    - run:
        command: |
          echo 'export CCI_STATUS="fail"' > /tmp/SLACK_JOB_STATUS
        name: Slack - Detecting Job Status (FAIL)
        when: on_fail
    - run:
        command: |
          echo 'export CCI_STATUS="pass"' > /tmp/SLACK_JOB_STATUS
        name: Slack - Detecting Job Status (PASS)
        when: on_success
    - run:
        command: |
          BuildMessageBody() {
              # Send message
              #   If sending message, default to custom template,
              #   if none is supplied, check for a pre-selected template value.
              #   If none, error.
              if [ -n "$SLACK_PARAM_CUSTOM" ]; then
                  ModifyCustomTemplate
                  # shellcheck disable=SC2016
                  CUSTOM_BODY_MODIFIED=$(echo "$CUSTOM_BODY_MODIFIED" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed 's/`/\\`/g')
                  T2=$(eval echo \""$CUSTOM_BODY_MODIFIED"\")
              elif [ -n "$SLACK_PARAM_TEMPLATE" ]; then
                  TEMPLATE="\$$SLACK_PARAM_TEMPLATE"
                  T1=$(eval echo "$TEMPLATE" | sed 's/"/\\"/g')
                  T2=$(eval echo \""$T1"\")
              else
                  echo "Error: No message template selected."
                  echo "Select either a custom template or one of the pre-included ones via the 'custom' or 'template' parameters."
                  exit 1
              fi
              # Insert the default channel. THIS IS TEMPORARY
              T2=$(echo "$T2" | jq ". + {\"channel\": \"$SLACK_DEFAULT_CHANNEL\"}")
              SLACK_MSG_BODY=$T2
          }


          PostToSlack() {
              # Post once per channel listed by the channel parameter
              #    The channel must be modified in SLACK_MSG_BODY

              # shellcheck disable=SC2001
              for i in $(eval echo \""$SLACK_PARAM_CHANNEL"\" | sed "s/,/ /g")
              do
                  echo "Sending to Slack Channel: $i"
                  SLACK_MSG_BODY=$(echo "$SLACK_MSG_BODY" | jq --arg channel "$i" '.channel = $channel')
                  SLACK_SENT_RESPONSE=$(curl -s -f -X POST -H 'Content-type: application/json' -H "Authorization: Bearer $SLACK_ACCESS_TOKEN" --data "$SLACK_MSG_BODY" https://slack.com/api/chat.postMessage)
                  SLACK_ERROR_MSG=$(echo "$SLACK_SENT_RESPONSE" | jq '.error')
                  if [ ! "$SLACK_ERROR_MSG" = "null" ]; then
                      echo "Slack API returned an error message:"
                      echo "$SLACK_ERROR_MSG"
                      echo
                      echo
                      echo "View the Setup Guide: https://github.com/CircleCI-Public/slack-orb/wiki/Setup"
                      if [ "$SLACK_PARAM_IGNORE_ERRORS" = "0" ]; then
                          exit 1
                      fi
                  fi
              done
          }

          ModifyCustomTemplate() {
              # Inserts the required "text" field to the custom json template from block kit builder.
              if [ "$(echo "$SLACK_PARAM_CUSTOM" | jq '.text')" = "null" ]; then
                  CUSTOM_BODY_MODIFIED=$(echo "$SLACK_PARAM_CUSTOM" | jq '. + {"text": ""}')
              else
                  # In case the text field was set manually.
                  CUSTOM_BODY_MODIFIED=$(echo "$SLACK_PARAM_CUSTOM" | jq '.')
              fi
          }

          InstallJq() {
              if uname -a | grep Darwin > /dev/null 2>&1; then
                  echo "Checking For JQ + CURL: MacOS"
                  command -v jq >/dev/null 2>&1 || HOMEBREW_NO_AUTO_UPDATE=1 brew install jq --quiet
                  return $?

              elif cat /etc/issue | grep Debian > /dev/null 2>&1 || cat /etc/issue | grep Ubuntu > /dev/null 2>&1; then
                  echo "Checking For JQ + CURL: Debian"
                  if [ "$(id -u)" = 0 ]; then export SUDO=""; else # Check if we're root
                      export SUDO="sudo";
                  fi
                  command -v jq >/dev/null 2>&1 || { $SUDO apt -qq update && $SUDO apt -qq install -y jq; }
                  return $?

              elif cat /etc/issue | grep Alpine > /dev/null 2>&1; then
                  echo "Checking For JQ + CURL: Alpine"
                  command -v curl >/dev/null 2>&1 || { echo >&2 "SLACK ORB ERROR: CURL is required. Please install."; exit 1; }
                  command -v jq >/dev/null 2>&1 || { echo >&2 "SLACK ORB ERROR: JQ is required. Please install"; exit 1; }
                  return $?
              fi
          }

          FilterBy() {
              if [ -z "$1" ] || [ -z "$2" ]; then
                return
              fi

              # If any pattern supplied matches the current branch or the current tag, proceed; otherwise, exit with message.
              FLAG_MATCHES_FILTER="false"
              for i in $(echo "$1" | sed "s/,/ /g")
              do
                  if echo "$2" | grep -Eq "^${i}$"; then
                      FLAG_MATCHES_FILTER="true"
                      break
                  fi
              done
              if [ "$FLAG_MATCHES_FILTER" = "false" ]; then
                  # dont send message.
                  echo "NO SLACK ALERT"
                  echo
                  echo "Current reference \"$2\" does not match any matching parameter"
                  echo "Current matching pattern: $1"
                  exit 0
              fi
          }

          CheckEnvVars() {
              if [ -z "$SLACK_ACCESS_TOKEN" ]; then
                  echo "In order to use the Slack Orb (v4 +), an OAuth token must be present via the SLACK_ACCESS_TOKEN environment variable."
                  echo "Follow the setup guide available in the wiki: https://github.com/CircleCI-Public/slack-orb/wiki/Setup"
                  exit 1
              fi
              # If no channel is provided, quit with error
              if [ -z "$SLACK_PARAM_CHANNEL" ]; then
                 echo "No channel was provided. Enter value for SLACK_DEFAULT_CHANNEL env var, or channel parameter"
                 exit 1
              fi
              if [ -n "$SLACK_WEBHOOK" ]; then
                  echo "It appears you have a Slack Webhook token present in this job."
                  echo "Please note, Webhooks are no longer used for the Slack Orb (v4 +)."
                  echo "Follow the setup guide available in the wiki: https://github.com/CircleCI-Public/slack-orb/wiki/Setup"
              fi
          }

          ShouldPost() {
              if [ "$CCI_STATUS" = "$SLACK_PARAM_EVENT" ] || [ "$SLACK_PARAM_EVENT" = "always" ]; then
                  # In the event the Slack notification would be sent, first ensure it is allowed to trigger
                  # on this branch or this tag.
                  FilterBy "$SLACK_PARAM_BRANCHPATTERN" "$CIRCLE_BRANCH"
                  FilterBy "$SLACK_PARAM_TAGPATTERN" "$CIRCLE_TAG"

                  echo "Posting Status"
              else
                  # dont send message.
                  echo "NO SLACK ALERT"
                  echo
                  echo "This command is set to send an alert on: $SLACK_PARAM_EVENT"
                  echo "Current status: ${CCI_STATUS}"
                  exit 0
              fi
          }

          # Will not run if sourced from another script.
          # This is done so this script may be tested.
          ORB_TEST_ENV="bats-core"
          if [ "${0#*$ORB_TEST_ENV}" = "$0" ]; then
              CheckEnvVars
              . "/tmp/SLACK_JOB_STATUS"
              ShouldPost
              InstallJq
              BuildMessageBody
              PostToSlack

          fi
        environment:
          SLACK_PARAM_BRANCHPATTERN: .+
          SLACK_PARAM_CHANNEL: $SLACK_DEFAULT_CHANNEL
          SLACK_PARAM_CUSTOM: ''
          SLACK_PARAM_EVENT: pass
          SLACK_PARAM_IGNORE_ERRORS: true
          SLACK_PARAM_MENTIONS: ''
          SLACK_PARAM_TAGPATTERN: .+
          SLACK_PARAM_TEMPLATE: basic_success_1
          basic_fail_1: "{\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"Job Failed. :red_circle:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Job*: ${CIRCLE_JOB}\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Branch*:\\\\n$CIRCLE_BRANCH\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Author*:\\\\n$CIRCLE_USERNAME\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Mentions*:\\\\n$SLACK_PARAM_MENTIONS\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Job\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"${CIRCLE_BUILD_URL}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}\n"
          basic_on_hold_1: "{\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"ON HOLD - Awaiting Approval :raised_hand:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Branch*:\\\\n$CIRCLE_BRANCH\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Author*:\\\\n$CIRCLE_USERNAME\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Mentions*:\\\\n$SLACK_PARAM_MENTIONS\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Workflow\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"https://circleci.com/workflow-run/${CIRCLE_WORKFLOW_ID}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}"
          basic_success_1: "{\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"Job Succeeded. :white_check_mark:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Job*: ${CIRCLE_JOB}\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Branch*:\\\\n$CIRCLE_BRANCH\"\n                },\n                {\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Commit*:\\\\n$CIRCLE_SHA1\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Author*:\\\\n$CIRCLE_USERNAME\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Job\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"${CIRCLE_BUILD_URL}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}\n"
          success_tagged_deploy_1: "{\n\t\"text\": \"\",\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"Deployment Successful! :tada:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*When*:\\\\n$(date +'%m/%d/%Y %T')\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Tag*:\\\\n$CIRCLE_TAG\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Job\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"${CIRCLE_BUILD_URL}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}"
        name: Slack - Sending Notification
        when: always
    - run:
        command: |
          echo 'export CCI_STATUS="fail"' > /tmp/SLACK_JOB_STATUS
        name: Slack - Detecting Job Status (FAIL)
        when: on_fail
    - run:
        command: |
          echo 'export CCI_STATUS="pass"' > /tmp/SLACK_JOB_STATUS
        name: Slack - Detecting Job Status (PASS)
        when: on_success
    - run:
        command: |
          BuildMessageBody() {
              # Send message
              #   If sending message, default to custom template,
              #   if none is supplied, check for a pre-selected template value.
              #   If none, error.
              if [ -n "$SLACK_PARAM_CUSTOM" ]; then
                  ModifyCustomTemplate
                  # shellcheck disable=SC2016
                  CUSTOM_BODY_MODIFIED=$(echo "$CUSTOM_BODY_MODIFIED" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed 's/`/\\`/g')
                  T2=$(eval echo \""$CUSTOM_BODY_MODIFIED"\")
              elif [ -n "$SLACK_PARAM_TEMPLATE" ]; then
                  TEMPLATE="\$$SLACK_PARAM_TEMPLATE"
                  T1=$(eval echo "$TEMPLATE" | sed 's/"/\\"/g')
                  T2=$(eval echo \""$T1"\")
              else
                  echo "Error: No message template selected."
                  echo "Select either a custom template or one of the pre-included ones via the 'custom' or 'template' parameters."
                  exit 1
              fi
              # Insert the default channel. THIS IS TEMPORARY
              T2=$(echo "$T2" | jq ". + {\"channel\": \"$SLACK_DEFAULT_CHANNEL\"}")
              SLACK_MSG_BODY=$T2
          }


          PostToSlack() {
              # Post once per channel listed by the channel parameter
              #    The channel must be modified in SLACK_MSG_BODY

              # shellcheck disable=SC2001
              for i in $(eval echo \""$SLACK_PARAM_CHANNEL"\" | sed "s/,/ /g")
              do
                  echo "Sending to Slack Channel: $i"
                  SLACK_MSG_BODY=$(echo "$SLACK_MSG_BODY" | jq --arg channel "$i" '.channel = $channel')
                  SLACK_SENT_RESPONSE=$(curl -s -f -X POST -H 'Content-type: application/json' -H "Authorization: Bearer $SLACK_ACCESS_TOKEN" --data "$SLACK_MSG_BODY" https://slack.com/api/chat.postMessage)
                  SLACK_ERROR_MSG=$(echo "$SLACK_SENT_RESPONSE" | jq '.error')
                  if [ ! "$SLACK_ERROR_MSG" = "null" ]; then
                      echo "Slack API returned an error message:"
                      echo "$SLACK_ERROR_MSG"
                      echo
                      echo
                      echo "View the Setup Guide: https://github.com/CircleCI-Public/slack-orb/wiki/Setup"
                      if [ "$SLACK_PARAM_IGNORE_ERRORS" = "0" ]; then
                          exit 1
                      fi
                  fi
              done
          }

          ModifyCustomTemplate() {
              # Inserts the required "text" field to the custom json template from block kit builder.
              if [ "$(echo "$SLACK_PARAM_CUSTOM" | jq '.text')" = "null" ]; then
                  CUSTOM_BODY_MODIFIED=$(echo "$SLACK_PARAM_CUSTOM" | jq '. + {"text": ""}')
              else
                  # In case the text field was set manually.
                  CUSTOM_BODY_MODIFIED=$(echo "$SLACK_PARAM_CUSTOM" | jq '.')
              fi
          }

          InstallJq() {
              if uname -a | grep Darwin > /dev/null 2>&1; then
                  echo "Checking For JQ + CURL: MacOS"
                  command -v jq >/dev/null 2>&1 || HOMEBREW_NO_AUTO_UPDATE=1 brew install jq --quiet
                  return $?

              elif cat /etc/issue | grep Debian > /dev/null 2>&1 || cat /etc/issue | grep Ubuntu > /dev/null 2>&1; then
                  echo "Checking For JQ + CURL: Debian"
                  if [ "$(id -u)" = 0 ]; then export SUDO=""; else # Check if we're root
                      export SUDO="sudo";
                  fi
                  command -v jq >/dev/null 2>&1 || { $SUDO apt -qq update && $SUDO apt -qq install -y jq; }
                  return $?

              elif cat /etc/issue | grep Alpine > /dev/null 2>&1; then
                  echo "Checking For JQ + CURL: Alpine"
                  command -v curl >/dev/null 2>&1 || { echo >&2 "SLACK ORB ERROR: CURL is required. Please install."; exit 1; }
                  command -v jq >/dev/null 2>&1 || { echo >&2 "SLACK ORB ERROR: JQ is required. Please install"; exit 1; }
                  return $?
              fi
          }

          FilterBy() {
              if [ -z "$1" ] || [ -z "$2" ]; then
                return
              fi

              # If any pattern supplied matches the current branch or the current tag, proceed; otherwise, exit with message.
              FLAG_MATCHES_FILTER="false"
              for i in $(echo "$1" | sed "s/,/ /g")
              do
                  if echo "$2" | grep -Eq "^${i}$"; then
                      FLAG_MATCHES_FILTER="true"
                      break
                  fi
              done
              if [ "$FLAG_MATCHES_FILTER" = "false" ]; then
                  # dont send message.
                  echo "NO SLACK ALERT"
                  echo
                  echo "Current reference \"$2\" does not match any matching parameter"
                  echo "Current matching pattern: $1"
                  exit 0
              fi
          }

          CheckEnvVars() {
              if [ -z "$SLACK_ACCESS_TOKEN" ]; then
                  echo "In order to use the Slack Orb (v4 +), an OAuth token must be present via the SLACK_ACCESS_TOKEN environment variable."
                  echo "Follow the setup guide available in the wiki: https://github.com/CircleCI-Public/slack-orb/wiki/Setup"
                  exit 1
              fi
              # If no channel is provided, quit with error
              if [ -z "$SLACK_PARAM_CHANNEL" ]; then
                 echo "No channel was provided. Enter value for SLACK_DEFAULT_CHANNEL env var, or channel parameter"
                 exit 1
              fi
              if [ -n "$SLACK_WEBHOOK" ]; then
                  echo "It appears you have a Slack Webhook token present in this job."
                  echo "Please note, Webhooks are no longer used for the Slack Orb (v4 +)."
                  echo "Follow the setup guide available in the wiki: https://github.com/CircleCI-Public/slack-orb/wiki/Setup"
              fi
          }

          ShouldPost() {
              if [ "$CCI_STATUS" = "$SLACK_PARAM_EVENT" ] || [ "$SLACK_PARAM_EVENT" = "always" ]; then
                  # In the event the Slack notification would be sent, first ensure it is allowed to trigger
                  # on this branch or this tag.
                  FilterBy "$SLACK_PARAM_BRANCHPATTERN" "$CIRCLE_BRANCH"
                  FilterBy "$SLACK_PARAM_TAGPATTERN" "$CIRCLE_TAG"

                  echo "Posting Status"
              else
                  # dont send message.
                  echo "NO SLACK ALERT"
                  echo
                  echo "This command is set to send an alert on: $SLACK_PARAM_EVENT"
                  echo "Current status: ${CCI_STATUS}"
                  exit 0
              fi
          }

          # Will not run if sourced from another script.
          # This is done so this script may be tested.
          ORB_TEST_ENV="bats-core"
          if [ "${0#*$ORB_TEST_ENV}" = "$0" ]; then
              CheckEnvVars
              . "/tmp/SLACK_JOB_STATUS"
              ShouldPost
              InstallJq
              BuildMessageBody
              PostToSlack

          fi
        environment:
          SLACK_PARAM_BRANCHPATTERN: .+
          SLACK_PARAM_CHANNEL: $SLACK_DEFAULT_CHANNEL
          SLACK_PARAM_CUSTOM: ''
          SLACK_PARAM_EVENT: fail
          SLACK_PARAM_IGNORE_ERRORS: true
          SLACK_PARAM_MENTIONS: ''
          SLACK_PARAM_TAGPATTERN: .+
          SLACK_PARAM_TEMPLATE: basic_on_hold_1
          basic_fail_1: "{\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"Job Failed. :red_circle:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Job*: ${CIRCLE_JOB}\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Branch*:\\\\n$CIRCLE_BRANCH\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Author*:\\\\n$CIRCLE_USERNAME\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Mentions*:\\\\n$SLACK_PARAM_MENTIONS\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Job\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"${CIRCLE_BUILD_URL}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}\n"
          basic_on_hold_1: "{\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"ON HOLD - Awaiting Approval :raised_hand:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Branch*:\\\\n$CIRCLE_BRANCH\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Author*:\\\\n$CIRCLE_USERNAME\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Mentions*:\\\\n$SLACK_PARAM_MENTIONS\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Workflow\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"https://circleci.com/workflow-run/${CIRCLE_WORKFLOW_ID}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}"
          basic_success_1: "{\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"Job Succeeded. :white_check_mark:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Job*: ${CIRCLE_JOB}\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Branch*:\\\\n$CIRCLE_BRANCH\"\n                },\n                {\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Commit*:\\\\n$CIRCLE_SHA1\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Author*:\\\\n$CIRCLE_USERNAME\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Job\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"${CIRCLE_BUILD_URL}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}\n"
          success_tagged_deploy_1: "{\n\t\"text\": \"\",\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"Deployment Successful! :tada:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*When*:\\\\n$(date +'%m/%d/%Y %T')\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Tag*:\\\\n$CIRCLE_TAG\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Job\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"${CIRCLE_BUILD_URL}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}"
        name: Slack - Sending Notification
        when: always
  deployment-staging-build-notify:
    docker:
    - image: cimg/node:14.15.1-browsers
    steps:
    - run:
        name: Prepare Template
        when: always
        command: |
          SHORT_SHA1=`echo -n $CIRCLE_SHA1 | head -c 7`

          if [ `echo "$CIRCLE_REPOSITORY_URL" | grep "^git@github.com"` ]; then
            COMMIT_LINK=\[$SHORT_SHA1\]\(https://github.com/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/commit/$CIRCLE_SHA1\)
          elif [ `echo "$CIRCLE_REPOSITORY_URL" | grep "^git@bitbucket.org"` ]; then
            COMMIT_LINK=\[$SHORT_SHA1\]\(https://bitbucket.org/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/commit/$CIRCLE_SHA1\)
          else
            >&2 echo unknown version control system: $CIRCLE_REPOSITORY_URL
            fail
          fi

          # Note that the "<<" in the heredoc declaration is escaped from
          # CircleCI's parameters syntax.
          MS_TEAMS_MSG_TEMPLATE=$(cat <<END_HEREDOC
          {
            "@type": "MessageCard",
            "@context": "http://schema.org/extensions",
            "themeCdocker_jobolor": "__theme_color__",
            "summary": "CircleCI Build Notification",
            "sections": [
              {
                "activityTitle": "__build_status__: $CIRCLE_PROJECT_REPONAME job [${CIRCLE_JOB} #${CIRCLE_BUILD_NUM}]($CIRCLE_BUILD_URL)",
                "facts": [
                  {
                    "name": "Git ref",
                    "value": "$CIRCLE_BRANCH $CIRCLE_TAG"
                  },
                  {
                    "name": "Commit",
                    "value": "$COMMIT_LINK"
                  }
                ],
                "markdown": true
              }
            ]
          }
          END_HEREDOC
          )
          echo "$MS_TEAMS_MSG_TEMPLATE" > /tmp/ms_teams_message
    - run:
        name: Report Build Success
        command: |
          MSG_PATH=/tmp/ms_teams_success_message
          sed -e 's/__build_status__/Success/' -e 's/__theme_color__/14a603/' \
              /tmp/ms_teams_message > $MSG_PATH
          curl --fail -H "Content-Type: application/json" \
                --data-binary @$MSG_PATH \
                https://eldmandate.webhook.office.com/webhookb2/37002470-5070-4f01-b6ed-3bcc44180824@6a4f939d-635f-454d-9d19-7926a1208c06/IncomingWebhook/aae189ec52a04f04bd7d2c6e8271461d/aea37b94-7ffa-42b8-9cbe-014d0a48e677
        when: on_success
    - run:
        name: Report Build Failure
        command: |
          MSG_PATH=/tmp/ms_teams_failure_message
          sed -e 's/__build_status__/Failed/' -e 's/__theme_color__/e2091d/' \
              /tmp/ms_teams_message > $MSG_PATH
          curl --fail -H "Content-Type: application/json" \
                --data-binary @$MSG_PATH \
                https://eldmandate.webhook.office.com/webhookb2/37002470-5070-4f01-b6ed-3bcc44180824@6a4f939d-635f-454d-9d19-7926a1208c06/IncomingWebhook/aae189ec52a04f04bd7d2c6e8271461d/aea37b94-7ffa-42b8-9cbe-014d0a48e677
        when: on_fail
  aws-ecs/deploy-service-update-prod:
    docker:
    - image: circleci/python:3.7.1
    steps:
    - run:
        name: Install AWS CLI
        command: |
          export PIP=$(which pip pip3 | head -1)
          if [[ -n $PIP ]]; then
            if which sudo > /dev/null; then
              sudo $PIP install awscli --upgrade
            else
              # This installs the AWS CLI to ~/.local/bin. Make sure that ~/.local/bin is in your $PATH.
              $PIP install aws --upgrade --user
            fi
          elif [[ $(which unzip curl | wc -l) -eq 2 ]]; then
            cd
            curl "https://s3.amazonaws.com/aws-cli/awscli-bundle.zip" -o "awscli-bundle.zip"
            unzip awscli-bundle.zip
            if which sudo > /dev/null; then
              sudo ~/awscli-bundle/install -i /usr/local/aws -b /usr/local/bin/aws
            else
              # This installs the AWS CLI to the default location (~/.local/lib/aws) and create a symbolic link (symlink) at ~/bin/aws. Make sure that ~/bin is in your $PATH.
              awscli-bundle/install -b ~/bin/aws
            fi
            rm -rf awscli-bundle*
            cd -
          else
            echo "Unable to install AWS CLI. Please install pip."
            exit 1
          fi
    - run:
        name: Configure AWS Access Key ID
        command: |
          aws configure set aws_access_key_id \
          $AWS_ACCESS_KEY_ID \
          --profile default
    - run:
        name: Configure AWS Secret Access Key
        command: |
          aws configure set aws_secret_access_key \
          $AWS_SECRET_ACCESS_KEY \
          --profile default
    - run:
        name: Configure AWS default region
        command: |
          aws configure set region $AWS_REGION \
          --profile default
    - run:
        name: Retrieve previous task definition and prepare new task definition values
        command: |
          set -o noglob
          PREVIOUS_TASK_DEFINITION=$(aws ecs describe-task-definition --task-definition prod-assettracker-api-microservice --include TAGS)
          CONTAINER_IMAGE_NAME_UPDATES="$(echo container=prod-assettracker-api-microservice,tag=${CIRCLE_SHA1})"
          CONTAINER_ENV_VAR_UPDATES="$(echo )"

          # Prepare script for updating container definitions
          UPDATE_CONTAINER_DEFS_SCRIPT_FILE=$(mktemp _update_container_defs.py.XXXXXX)
          chmod +x $UPDATE_CONTAINER_DEFS_SCRIPT_FILE
          cat > $UPDATE_CONTAINER_DEFS_SCRIPT_FILE <<-EOF
          from __future__ import absolute_import
          import sys
          import json


          def run(previous_task_definition, container_image_name_updates, container_env_var_updates):
              try:
                  definition = json.loads(previous_task_definition)
                  container_definitions = definition['taskDefinition']['containerDefinitions']
              except:
                  raise Exception('No valid task definition found: ' +
                                  previous_task_definition)

              # Build a map of the original container definitions so that the
              # array index positions can be easily looked up
              container_map = {}
              for index, container_definition in enumerate(container_definitions):
                  env_var_map = {}
                  env_var_definitions = container_definition.get('environment')
                  if env_var_definitions is not None:
                      for env_var_index, env_var_definition in enumerate(env_var_definitions):
                          env_var_map[env_var_definition['name']] = {
                              'index': env_var_index}
                  container_map[container_definition['name']] = {
                      'image': container_definition['image'], 'index': index, 'environment_map': env_var_map}

              # Expected format: container=...,name=...,value=...,container=...,name=...,value=
              try:
                  env_kv_pairs = container_env_var_updates.split(',')
                  for index, kv_pair in enumerate(env_kv_pairs):
                      kv = kv_pair.split('=')
                      key = kv[0].strip()

                      if key == 'container':
                          container_name = kv[1].strip()
                          env_var_name_kv = env_kv_pairs[index+1].split('=')
                          env_var_name = env_var_name_kv[1].strip()
                          env_var_value_kv = env_kv_pairs[index+2].split('=')
                          env_var_value = env_var_value_kv[1].strip()
                          if env_var_name_kv[0].strip() != 'name' or env_var_value_kv[0].strip() != 'value':
                              raise ValueError(
                                  'Environment variable update parameter format is incorrect: ' + container_env_var_updates)

                          container_entry = container_map.get(container_name)
                          if container_entry is None:
                              raise ValueError('The container ' + container_name +
                                               ' is not defined in the existing task definition')
                          container_index = container_entry['index']
                          env_var_entry = container_entry['environment_map'].get(
                              env_var_name)
                          if env_var_entry is None:
                              # The existing container definition did not contain environment variables
                              if container_definitions[container_index].get('environment') is None:
                                  container_definitions[container_index]['environment'] = []
                              # This env var did not exist in the existing container definition
                              container_definitions[container_index]['environment'].append({'name': env_var_name, 'value': env_var_value})
                          else:
                              env_var_index = env_var_entry['index']
                              container_definitions[container_index]['environment'][env_var_index]['value'] = env_var_value
                      elif key and key not in ['container', 'name', 'value']:
                          raise ValueError(
                              'Incorrect key found in environment variable update parameter: ' + key)
              except ValueError as value_error:
                  raise value_error
              except:
                  raise Exception(
                      'Environment variable update parameter could not be processed; please check parameter value: ' + container_env_var_updates)

              # Expected format: container=...,image-and-tag|image|tag=...,container=...,image-and-tag|image|tag=...,
              try:
                  if container_image_name_updates and "container=" not in container_image_name_updates:
                      raise ValueError(
                          'The container parameter is required in the container_image_name_updates variable.')

                  image_kv_pairs = container_image_name_updates.split(',')
                  for index, kv_pair in enumerate(image_kv_pairs):
                      kv = kv_pair.split('=')
                      key = kv[0].strip()
                      if key == 'container':
                          container_name = kv[1].strip()
                          image_kv = image_kv_pairs[index+1].split('=')
                          container_entry = container_map.get(container_name)
                          if container_entry is None:
                              raise ValueError('The container ' + container_name +
                                               ' is not defined in the existing task definition')
                          container_index = container_entry['index']
                          image_specifier_type = image_kv[0].strip()
                          image_value = image_kv[1].strip()
                          if image_specifier_type == 'image-and-tag':
                              container_definitions[container_index]['image'] = image_value
                          else:
                              existing_image_name_tokens = container_entry['image'].split(
                                  ':')
                              if image_specifier_type == 'image':
                                  tag = ''
                                  if len(existing_image_name_tokens) == 2:
                                      tag = ':' + existing_image_name_tokens[1]
                                  container_definitions[container_index]['image'] = image_value + tag
                              elif image_specifier_type == 'tag':
                                  container_definitions[container_index]['image'] = existing_image_name_tokens[0] + \
                                      ':' + image_value
                              else:
                                  raise ValueError(
                                      'Image name update parameter format is incorrect: ' + container_image_name_updates)
                      elif key and key not in ['container', 'image', 'image-and-tag', 'tag']:
                          raise ValueError(
                              'Incorrect key found in image name update parameter: ' + key)

              except ValueError as value_error:
                  raise value_error
              except:
                  raise Exception(
                      'Image name update parameter could not be processed; please check parameter value: ' + container_image_name_updates)
              return json.dumps(container_definitions)


          if __name__ == '__main__':
              try:
                  print(run(sys.argv[1], sys.argv[2], sys.argv[3]))
              except Exception as e:
                  sys.stderr.write(str(e) + "\n")
                  exit(1)

          EOF

          # Prepare container definitions
          CONTAINER_DEFS=$(python $UPDATE_CONTAINER_DEFS_SCRIPT_FILE "$PREVIOUS_TASK_DEFINITION" "$CONTAINER_IMAGE_NAME_UPDATES" "$CONTAINER_ENV_VAR_UPDATES")

          # Escape single quotes from environment variables for BASH_ENV
          CLEANED_CONTAINER_DEFS=$(echo "$CONTAINER_DEFS" | sed -E "s:':'\\\'':g")

          # Prepare script for getting task definition values
          GET_TASK_DFN_VAL_SCRIPT_FILE=$(mktemp _get_task_def_value.py.XXXXXX)
          chmod +x $GET_TASK_DFN_VAL_SCRIPT_FILE
          cat > $GET_TASK_DFN_VAL_SCRIPT_FILE <<-EOF
          from __future__ import absolute_import
          import sys
          import json


          def run(element_name, task_definition_str):
              try:
                  definition = json.loads(task_definition_str)
                  task_definition = definition['taskDefinition']
              except:
                  raise Exception('No valid task definition found: ' +
                                  task_definition_str)
              str_list_types = ['requiresCompatibilities']
              json_arr_types = ['placementConstraints', 'volumes', 'tags']
              json_obj_types = ['proxyConfiguration']
              if element_name in json_arr_types:
                  output_value = '[]'
              elif element_name in json_obj_types:
                  output_value = '{}'
              else:
                  output_value = ''
              if element_name == 'tags':
                  if element_name in definition:
                      element_value = definition[element_name]
                      output_value = json.dumps(element_value)
              elif element_name in task_definition:
                  element_value = task_definition[element_name]
                  if element_name in str_list_types:
                      output_value = ' '.join(list_item.strip() for list_item in element_value)
                  elif element_name in json_arr_types or element_name in json_obj_types:
                      output_value = json.dumps(element_value)
                  else:
                      output_value = str(element_value)
              return output_value


          if __name__ == '__main__':
              try:
                  print(run(sys.argv[1], sys.argv[2]))
              except Exception as e:
                  sys.stderr.write(str(e) + "\n")
                  exit(1)

          EOF

          # Get other task definition values
          TASK_ROLE=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'taskRoleArn' "$PREVIOUS_TASK_DEFINITION")
          EXECUTION_ROLE=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'executionRoleArn' "$PREVIOUS_TASK_DEFINITION")
          NETWORK_MODE=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'networkMode' "$PREVIOUS_TASK_DEFINITION")
          VOLUMES=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'volumes' "$PREVIOUS_TASK_DEFINITION")
          PLACEMENT_CONSTRAINTS=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'placementConstraints' "$PREVIOUS_TASK_DEFINITION")
          REQ_COMP=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'requiresCompatibilities' "$PREVIOUS_TASK_DEFINITION")
          TASK_CPU=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'cpu' "$PREVIOUS_TASK_DEFINITION")
          TASK_MEMORY=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'memory' "$PREVIOUS_TASK_DEFINITION")
          PID_MODE=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'pidMode' "$PREVIOUS_TASK_DEFINITION")
          IPC_MODE=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'ipcMode' "$PREVIOUS_TASK_DEFINITION")
          TAGS=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'tags' "$PREVIOUS_TASK_DEFINITION")
          PROXY_CONFIGURATION=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'proxyConfiguration' "$PREVIOUS_TASK_DEFINITION")

          # Make task definition values available as env variables
          echo "export CCI_ORB_AWS_ECS_TASK_ROLE='${TASK_ROLE}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_EXECUTION_ROLE='${EXECUTION_ROLE}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_NETWORK_MODE='${NETWORK_MODE}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_CONTAINER_DEFS='${CLEANED_CONTAINER_DEFS}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_VOLUMES='${VOLUMES}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_PLACEMENT_CONSTRAINTS='${PLACEMENT_CONSTRAINTS}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_REQ_COMP='${REQ_COMP}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_TASK_CPU='${TASK_CPU}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_TASK_MEMORY='${TASK_MEMORY}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_PID_MODE='${PID_MODE}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_IPC_MODE='${IPC_MODE}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_TAGS='${TAGS}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_PROXY_CONFIGURATION='${PROXY_CONFIGURATION}'" >> $BASH_ENV

          rm $UPDATE_CONTAINER_DEFS_SCRIPT_FILE $GET_TASK_DFN_VAL_SCRIPT_FILE
    - run:
        name: Register new task definition
        command: |
          set -o noglob
          if [ -n "${CCI_ORB_AWS_ECS_TASK_ROLE}" ]; then
              set -- "$@" --task-role-arn "${CCI_ORB_AWS_ECS_TASK_ROLE}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_EXECUTION_ROLE}" ]; then
              set -- "$@" --execution-role-arn "${CCI_ORB_AWS_ECS_EXECUTION_ROLE}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_NETWORK_MODE}" ]; then
              set -- "$@" --network-mode "${CCI_ORB_AWS_ECS_NETWORK_MODE}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_VOLUMES}" ] && [ "${CCI_ORB_AWS_ECS_VOLUMES}" != "[]" ]; then
              set -- "$@" --volumes "${CCI_ORB_AWS_ECS_VOLUMES}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_PLACEMENT_CONSTRAINTS}" ] && [ "${CCI_ORB_AWS_ECS_PLACEMENT_CONSTRAINTS}" != "[]" ]; then
              set -- "$@" --placement-constraints "${CCI_ORB_AWS_ECS_PLACEMENT_CONSTRAINTS}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_REQ_COMP}" ] && [ "${CCI_ORB_AWS_ECS_REQ_COMP}" != "[]" ]; then
              set -- "$@" --requires-compatibilities ${CCI_ORB_AWS_ECS_REQ_COMP}
          fi
          if [ -n "${CCI_ORB_AWS_ECS_TASK_CPU}" ]; then
              set -- "$@" --cpu "${CCI_ORB_AWS_ECS_TASK_CPU}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_TASK_MEMORY}" ]; then
              set -- "$@" --memory "${CCI_ORB_AWS_ECS_TASK_MEMORY}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_PID_MODE}" ]; then
              set -- "$@" --pid-mode "${CCI_ORB_AWS_ECS_PID_MODE}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_IPC_MODE}" ]; then
              set -- "$@" --ipc-mode "${CCI_ORB_AWS_ECS_IPC_MODE}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_TAGS}" ] && [ "${CCI_ORB_AWS_ECS_TAGS}" != "[]" ]; then
              set -- "$@" --tags "${CCI_ORB_AWS_ECS_TAGS}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_PROXY_CONFIGURATION}" ] && [ "${CCI_ORB_AWS_ECS_PROXY_CONFIGURATION}" != "{}" ]; then
              set -- "$@" --proxy-configuration "${CCI_ORB_AWS_ECS_PROXY_CONFIGURATION}"
          fi
          REVISION=$(aws ecs register-task-definition \
              --family prod-assettracker-api-microservice \
              --container-definitions "${CCI_ORB_AWS_ECS_CONTAINER_DEFS}" \
              "$@" \
              --output text \
              --query 'taskDefinition.taskDefinitionArn')
          echo "Registered task definition: ${REVISION}"
          echo "export CCI_ORB_AWS_ECS_REGISTERED_TASK_DFN='${REVISION}'" >> $BASH_ENV
    - run:
        name: Update service with registered task definition
        command: |
          set -o noglob
          SERVICE_NAME="$(echo prod-assettracker-api-microservice-2)"

          if [ -z "${SERVICE_NAME}" ]; then
              SERVICE_NAME="$(echo prod-assettracker-api-microservice)"
          fi
          if [ "false" == "true" ]; then
              set -- "$@" --force-new-deployment
          fi
          DEPLOYED_REVISION=$(aws ecs update-service \
              --cluster "prod-assettracker-api-microservice" \
              --service "${SERVICE_NAME}" \
              --task-definition "${CCI_ORB_AWS_ECS_REGISTERED_TASK_DFN}" \
              --output text \
              --query service.taskDefinition \
              "$@")
          echo "export CCI_ORB_AWS_ECS_DEPLOYED_REVISION='${DEPLOYED_REVISION}'" >> $BASH_ENV
  build_and_push_prod:
    machine: true
    steps:
    - checkout
    - run:
        name: Pull Submodules for Development
        command: |
          git submodule init
          git submodule update --remote
          cd eldmandate-data-layer
          git config --global user.email "circle@circle"
          git config --global user.name "circleci"
          git checkout master
          git pull origin master
          cd ..
    - checkout
    - run:
        command: |
          AWS_VER_REGEXP_2='aws-cli\/2.\d*.\d*'
          AWS_VER_REGEXP_1='aws-cli\/1.\d*.\d*'
          # initialize installed version to zero, to signify not installed (Or we want to ignore the installed version and re-install).
          AWS_CLI_INSTALLED_VERSION="0"
          AWS_CLI_VERSION_SELECTED="2"

          if [[ $EUID == 0 ]]; then export SUDO=""; else export SUDO="sudo"; fi

          if [ "false" == "false" ]; then
              if ! command -v aws --version >/dev/null 2>&1  ; then
                  echo AWS is not installed
              else
                  echo AWS is currently installed.
                  if aws --version 2>&1 | grep -q $AWS_VER_REGEXP_2; then
                      echo AWS CLI v2 is installed
                      AWS_CLI_INSTALLED_VERSION="2"
                  fi
                  if aws --version 2>&1 | grep -q $AWS_VER_REGEXP_1; then
                      echo AWS CLI v1 is installed
                      AWS_CLI_INSTALLED_VERSION="1"
                  fi
              fi
          else
              echo "Skipping version check. Installing CLI"
          fi

          AWS_V2_UPDATE_PARAM=""
          if aws --version 2>&1 | grep -q $AWS_VER_REGEXP_2; then
              AWS_V2_UPDATE_PARAM="--update"
          fi

          #If the desired version of the CLI is not installed, install it.
          if [[ $AWS_CLI_VERSION_SELECTED != $AWS_CLI_INSTALLED_VERSION ]]; then

              #uninstall AWS CLI if it is installed.
              if which aws; then
                  echo Uninstalling old CLI
                  $SUDO rm -rf $(which aws)
              fi
              case $AWS_CLI_VERSION_SELECTED in
                  "1")
                      if ! command -v python >/dev/null 2>&1 && ! command -v python3 >/dev/null 2>&1 ; then
                          echo "Your environment does not seem to have Python installed, a requirement of the AWS CLI."
                          echo "Please either utilize the AWS CLI v2, or select an envionment with Python installed."
                          echo "Recommended image: cimg:/python:3.8"
                          exit 1
                      fi
                      # install CLI v1
                      export PIP=$(which pip pip3 | head -1)
                      if [[ -n $PIP ]]; then
                          if which sudo > /dev/null; then
                              sudo $PIP install awscli --upgrade
                          else
                              # This installs the AWS CLI to ~/.local/bin. Make sure that ~/.local/bin is in your $PATH.
                              $PIP install awscli --upgrade --user
                          fi
                      elif [[ $(which unzip curl | wc -l) -eq 2 ]]; then
                          cd
                          curl "https://s3.amazonaws.com/aws-cli/awscli-bundle.zip" -o "awscli-bundle.zip"
                          unzip awscli-bundle.zip
                          if which sudo > /dev/null; then
                              sudo ~/awscli-bundle/install -i /usr/local/aws -b /usr/local/bin/aws
                          else
                              # This installs the AWS CLI to the default location (~/.local/lib/aws) and create a symbolic link (symlink) at ~/bin/aws. Make sure that ~/bin is in your $PATH.
                              awscli-bundle/install -b ~/bin/aws
                          fi
                          rm -rf awscli-bundle*
                          cd -
                      else
                          echo "Unable to install AWS CLI. Please install pip."
                          exit 1
                      fi
                      # Installation check
                      if aws --version &> grep -q "aws-cli/1"; then
                          echo "AWS CLI V1 has been installed successfully"
                          exit 0
                      else
                          echo "There was an issue installing the AWS CLI V1. Exiting."
                          exit 1
                      fi
                  ;;
                  "2")
                      # install CLI v2

                      cd /tmp || exit

                      # PLATFORM CHECK: mac vs. alpine vs. other linux
                      if uname -a | grep Darwin; then
                          SYS_ENV_PLATFORM=darwin
                      elif uname -a | grep Linux; then
                          SYS_ENV_PLATFORM=linux
                      else
                          echo "This platform appears to be unsupported."
                          uname -a
                          exit 1
                      fi

                      case $SYS_ENV_PLATFORM in
                          linux)
                              curl -sSL "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
                              unzip awscliv2.zip
                              $SUDO ./aws/install $AWS_V2_UPDATE_PARAM
                              rm awscliv2.zip
                              ;;
                          darwin)
                              curl -sSL "https://awscli.amazonaws.com/AWSCLIV2.pkg" -o "AWSCLIV2.pkg"
                              $SUDO installer -pkg AWSCLIV2.pkg -target /
                              rm AWSCLIV2.pkg
                              ;;
                          *)
                              echo "This orb does not currently support your platform. If you believe it should, please consider opening an issue on the GitHub repository:"
                              echo "https://github.com/CircleCI-Public/aws-cli-orb/issues/new"
                              exit 1
                          ;;
                      esac
                      # Installation check
                      if aws --version &> grep -q "aws-cli/2"; then
                          echo "AWS CLI V2 has been installed successfully"
                          exit 0
                      else
                          echo "There was an issue installing the AWS CLI V2. Exiting."
                          exit 1
                      fi
                  ;;
              esac

          else
              echo "The v${AWS_CLI_VERSION_SELECTED} AWS CLI is already installed."
              exit 0
          fi
        name: Install AWS CLI v2
    - run:
        command: |
          if [ -z "${AWS_PAGER}" ]; then
            echo 'export AWS_PAGER=""' >> $BASH_ENV
            echo "AWS_PAGER is being set to the empty string to disable all output paging for AWS CLI commands."
            echo "You can set the 'disable-aws-pager' parameter to 'false' to disable this behavior."
          fi
        name: Disable AWS pager if not already configured
    - run:
        command: |
          aws configure set aws_access_key_id \
            $AWS_ACCESS_KEY_ID \
            --profile default
        name: Configure AWS Access Key ID
    - run:
        command: |
          aws configure set aws_secret_access_key \
            $AWS_SECRET_ACCESS_KEY \
            --profile default
        name: Configure AWS Secret Access Key
    - run:
        command: |
          aws configure set default.region $AWS_REGION \
            --profile default
        name: Configure AWS default region
    - run:
        command: |
          # get-login-password returns a password that we pipe to the docker login command
          aws ecr get-login-password --region $AWS_REGION --profile default | docker login --username AWS --password-stdin $AWS_ECR_ACCOUNT_URL
        name: Log into Amazon ECR
    - run:
        command: |
          registry_id=$(echo $AWS_ECR_ACCOUNT_URL | sed "s;\..*;;g")
          number_of_tags_in_ecr=0

          docker_tag_args=""
          IFS="," read -ra DOCKER_TAGS <<< "${CIRCLE_SHA1}"
          for tag in "${DOCKER_TAGS[@]}"; do
            if [ "false" = "true" ]; then
              docker_tag_exists_in_ecr=$(aws ecr describe-images --registry-id $registry_id --repository-name prod-assettracker-api-microservice --query "contains(imageDetails[].imageTags[], '$tag')")
              if [ "$docker_tag_exists_in_ecr" = "true" ]; then
                docker pull $AWS_ECR_ACCOUNT_URL/prod-assettracker-api-microservice:${tag}
                let "number_of_tags_in_ecr+=1"
              fi
            fi
            docker_tag_args="$docker_tag_args -t $AWS_ECR_ACCOUNT_URL/prod-assettracker-api-microservice:$tag"
          done
          if [ "false" = "false" ] || [ "false" = "true" -a $number_of_tags_in_ecr -lt ${#DOCKER_TAGS[@]} ]; then
            docker build \
               \
              -f ./Dockerfile \
              $docker_tag_args \
              .
          fi
        name: Build docker image
        no_output_timeout: 10m
    - run:
        command: |
          IFS="," read -ra DOCKER_TAGS <<< "${CIRCLE_SHA1}"
          for tag in "${DOCKER_TAGS[@]}"; do
            docker push $AWS_ECR_ACCOUNT_URL/prod-assettracker-api-microservice:${tag}
          done
        name: Push image to Amazon ECR
    - run:
        command: |
          echo 'export CCI_STATUS="fail"' > /tmp/SLACK_JOB_STATUS
        name: Slack - Detecting Job Status (FAIL)
        when: on_fail
    - run:
        command: |
          echo 'export CCI_STATUS="pass"' > /tmp/SLACK_JOB_STATUS
        name: Slack - Detecting Job Status (PASS)
        when: on_success
    - run:
        command: |
          BuildMessageBody() {
              # Send message
              #   If sending message, default to custom template,
              #   if none is supplied, check for a pre-selected template value.
              #   If none, error.
              if [ -n "$SLACK_PARAM_CUSTOM" ]; then
                  ModifyCustomTemplate
                  # shellcheck disable=SC2016
                  CUSTOM_BODY_MODIFIED=$(echo "$CUSTOM_BODY_MODIFIED" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed 's/`/\\`/g')
                  T2=$(eval echo \""$CUSTOM_BODY_MODIFIED"\")
              elif [ -n "$SLACK_PARAM_TEMPLATE" ]; then
                  TEMPLATE="\$$SLACK_PARAM_TEMPLATE"
                  T1=$(eval echo "$TEMPLATE" | sed 's/"/\\"/g')
                  T2=$(eval echo \""$T1"\")
              else
                  echo "Error: No message template selected."
                  echo "Select either a custom template or one of the pre-included ones via the 'custom' or 'template' parameters."
                  exit 1
              fi
              # Insert the default channel. THIS IS TEMPORARY
              T2=$(echo "$T2" | jq ". + {\"channel\": \"$SLACK_DEFAULT_CHANNEL\"}")
              SLACK_MSG_BODY=$T2
          }


          PostToSlack() {
              # Post once per channel listed by the channel parameter
              #    The channel must be modified in SLACK_MSG_BODY

              # shellcheck disable=SC2001
              for i in $(eval echo \""$SLACK_PARAM_CHANNEL"\" | sed "s/,/ /g")
              do
                  echo "Sending to Slack Channel: $i"
                  SLACK_MSG_BODY=$(echo "$SLACK_MSG_BODY" | jq --arg channel "$i" '.channel = $channel')
                  SLACK_SENT_RESPONSE=$(curl -s -f -X POST -H 'Content-type: application/json' -H "Authorization: Bearer $SLACK_ACCESS_TOKEN" --data "$SLACK_MSG_BODY" https://slack.com/api/chat.postMessage)
                  SLACK_ERROR_MSG=$(echo "$SLACK_SENT_RESPONSE" | jq '.error')
                  if [ ! "$SLACK_ERROR_MSG" = "null" ]; then
                      echo "Slack API returned an error message:"
                      echo "$SLACK_ERROR_MSG"
                      echo
                      echo
                      echo "View the Setup Guide: https://github.com/CircleCI-Public/slack-orb/wiki/Setup"
                      if [ "$SLACK_PARAM_IGNORE_ERRORS" = "0" ]; then
                          exit 1
                      fi
                  fi
              done
          }

          ModifyCustomTemplate() {
              # Inserts the required "text" field to the custom json template from block kit builder.
              if [ "$(echo "$SLACK_PARAM_CUSTOM" | jq '.text')" = "null" ]; then
                  CUSTOM_BODY_MODIFIED=$(echo "$SLACK_PARAM_CUSTOM" | jq '. + {"text": ""}')
              else
                  # In case the text field was set manually.
                  CUSTOM_BODY_MODIFIED=$(echo "$SLACK_PARAM_CUSTOM" | jq '.')
              fi
          }

          InstallJq() {
              if uname -a | grep Darwin > /dev/null 2>&1; then
                  echo "Checking For JQ + CURL: MacOS"
                  command -v jq >/dev/null 2>&1 || HOMEBREW_NO_AUTO_UPDATE=1 brew install jq --quiet
                  return $?

              elif cat /etc/issue | grep Debian > /dev/null 2>&1 || cat /etc/issue | grep Ubuntu > /dev/null 2>&1; then
                  echo "Checking For JQ + CURL: Debian"
                  if [ "$(id -u)" = 0 ]; then export SUDO=""; else # Check if we're root
                      export SUDO="sudo";
                  fi
                  command -v jq >/dev/null 2>&1 || { $SUDO apt -qq update && $SUDO apt -qq install -y jq; }
                  return $?

              elif cat /etc/issue | grep Alpine > /dev/null 2>&1; then
                  echo "Checking For JQ + CURL: Alpine"
                  command -v curl >/dev/null 2>&1 || { echo >&2 "SLACK ORB ERROR: CURL is required. Please install."; exit 1; }
                  command -v jq >/dev/null 2>&1 || { echo >&2 "SLACK ORB ERROR: JQ is required. Please install"; exit 1; }
                  return $?
              fi
          }

          FilterBy() {
              if [ -z "$1" ] || [ -z "$2" ]; then
                return
              fi

              # If any pattern supplied matches the current branch or the current tag, proceed; otherwise, exit with message.
              FLAG_MATCHES_FILTER="false"
              for i in $(echo "$1" | sed "s/,/ /g")
              do
                  if echo "$2" | grep -Eq "^${i}$"; then
                      FLAG_MATCHES_FILTER="true"
                      break
                  fi
              done
              if [ "$FLAG_MATCHES_FILTER" = "false" ]; then
                  # dont send message.
                  echo "NO SLACK ALERT"
                  echo
                  echo "Current reference \"$2\" does not match any matching parameter"
                  echo "Current matching pattern: $1"
                  exit 0
              fi
          }

          CheckEnvVars() {
              if [ -z "$SLACK_ACCESS_TOKEN" ]; then
                  echo "In order to use the Slack Orb (v4 +), an OAuth token must be present via the SLACK_ACCESS_TOKEN environment variable."
                  echo "Follow the setup guide available in the wiki: https://github.com/CircleCI-Public/slack-orb/wiki/Setup"
                  exit 1
              fi
              # If no channel is provided, quit with error
              if [ -z "$SLACK_PARAM_CHANNEL" ]; then
                 echo "No channel was provided. Enter value for SLACK_DEFAULT_CHANNEL env var, or channel parameter"
                 exit 1
              fi
              if [ -n "$SLACK_WEBHOOK" ]; then
                  echo "It appears you have a Slack Webhook token present in this job."
                  echo "Please note, Webhooks are no longer used for the Slack Orb (v4 +)."
                  echo "Follow the setup guide available in the wiki: https://github.com/CircleCI-Public/slack-orb/wiki/Setup"
              fi
          }

          ShouldPost() {
              if [ "$CCI_STATUS" = "$SLACK_PARAM_EVENT" ] || [ "$SLACK_PARAM_EVENT" = "always" ]; then
                  # In the event the Slack notification would be sent, first ensure it is allowed to trigger
                  # on this branch or this tag.
                  FilterBy "$SLACK_PARAM_BRANCHPATTERN" "$CIRCLE_BRANCH"
                  FilterBy "$SLACK_PARAM_TAGPATTERN" "$CIRCLE_TAG"

                  echo "Posting Status"
              else
                  # dont send message.
                  echo "NO SLACK ALERT"
                  echo
                  echo "This command is set to send an alert on: $SLACK_PARAM_EVENT"
                  echo "Current status: ${CCI_STATUS}"
                  exit 0
              fi
          }

          # Will not run if sourced from another script.
          # This is done so this script may be tested.
          ORB_TEST_ENV="bats-core"
          if [ "${0#*$ORB_TEST_ENV}" = "$0" ]; then
              CheckEnvVars
              . "/tmp/SLACK_JOB_STATUS"
              ShouldPost
              InstallJq
              BuildMessageBody
              PostToSlack

          fi
        environment:
          SLACK_PARAM_BRANCHPATTERN: .+
          SLACK_PARAM_CHANNEL: $SLACK_DEFAULT_CHANNEL
          SLACK_PARAM_CUSTOM: ''
          SLACK_PARAM_EVENT: fail
          SLACK_PARAM_IGNORE_ERRORS: true
          SLACK_PARAM_MENTIONS: ''
          SLACK_PARAM_TAGPATTERN: .+
          SLACK_PARAM_TEMPLATE: basic_fail_1
          basic_fail_1: "{\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"Job Failed. :red_circle:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Job*: ${CIRCLE_JOB}\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Branch*:\\\\n$CIRCLE_BRANCH\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Author*:\\\\n$CIRCLE_USERNAME\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Mentions*:\\\\n$SLACK_PARAM_MENTIONS\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Job\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"${CIRCLE_BUILD_URL}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}\n"
          basic_on_hold_1: "{\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"ON HOLD - Awaiting Approval :raised_hand:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Branch*:\\\\n$CIRCLE_BRANCH\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Author*:\\\\n$CIRCLE_USERNAME\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Mentions*:\\\\n$SLACK_PARAM_MENTIONS\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Workflow\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"https://circleci.com/workflow-run/${CIRCLE_WORKFLOW_ID}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}"
          basic_success_1: "{\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"Job Succeeded. :white_check_mark:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Job*: ${CIRCLE_JOB}\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Branch*:\\\\n$CIRCLE_BRANCH\"\n                },\n                {\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Commit*:\\\\n$CIRCLE_SHA1\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Author*:\\\\n$CIRCLE_USERNAME\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Job\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"${CIRCLE_BUILD_URL}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}\n"
          success_tagged_deploy_1: "{\n\t\"text\": \"\",\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"Deployment Successful! :tada:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*When*:\\\\n$(date +'%m/%d/%Y %T')\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Tag*:\\\\n$CIRCLE_TAG\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Job\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"${CIRCLE_BUILD_URL}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}"
        name: Slack - Sending Notification
        when: always
    - run:
        command: |
          echo 'export CCI_STATUS="fail"' > /tmp/SLACK_JOB_STATUS
        name: Slack - Detecting Job Status (FAIL)
        when: on_fail
    - run:
        command: |
          echo 'export CCI_STATUS="pass"' > /tmp/SLACK_JOB_STATUS
        name: Slack - Detecting Job Status (PASS)
        when: on_success
    - run:
        command: |
          BuildMessageBody() {
              # Send message
              #   If sending message, default to custom template,
              #   if none is supplied, check for a pre-selected template value.
              #   If none, error.
              if [ -n "$SLACK_PARAM_CUSTOM" ]; then
                  ModifyCustomTemplate
                  # shellcheck disable=SC2016
                  CUSTOM_BODY_MODIFIED=$(echo "$CUSTOM_BODY_MODIFIED" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed 's/`/\\`/g')
                  T2=$(eval echo \""$CUSTOM_BODY_MODIFIED"\")
              elif [ -n "$SLACK_PARAM_TEMPLATE" ]; then
                  TEMPLATE="\$$SLACK_PARAM_TEMPLATE"
                  T1=$(eval echo "$TEMPLATE" | sed 's/"/\\"/g')
                  T2=$(eval echo \""$T1"\")
              else
                  echo "Error: No message template selected."
                  echo "Select either a custom template or one of the pre-included ones via the 'custom' or 'template' parameters."
                  exit 1
              fi
              # Insert the default channel. THIS IS TEMPORARY
              T2=$(echo "$T2" | jq ". + {\"channel\": \"$SLACK_DEFAULT_CHANNEL\"}")
              SLACK_MSG_BODY=$T2
          }


          PostToSlack() {
              # Post once per channel listed by the channel parameter
              #    The channel must be modified in SLACK_MSG_BODY

              # shellcheck disable=SC2001
              for i in $(eval echo \""$SLACK_PARAM_CHANNEL"\" | sed "s/,/ /g")
              do
                  echo "Sending to Slack Channel: $i"
                  SLACK_MSG_BODY=$(echo "$SLACK_MSG_BODY" | jq --arg channel "$i" '.channel = $channel')
                  SLACK_SENT_RESPONSE=$(curl -s -f -X POST -H 'Content-type: application/json' -H "Authorization: Bearer $SLACK_ACCESS_TOKEN" --data "$SLACK_MSG_BODY" https://slack.com/api/chat.postMessage)
                  SLACK_ERROR_MSG=$(echo "$SLACK_SENT_RESPONSE" | jq '.error')
                  if [ ! "$SLACK_ERROR_MSG" = "null" ]; then
                      echo "Slack API returned an error message:"
                      echo "$SLACK_ERROR_MSG"
                      echo
                      echo
                      echo "View the Setup Guide: https://github.com/CircleCI-Public/slack-orb/wiki/Setup"
                      if [ "$SLACK_PARAM_IGNORE_ERRORS" = "0" ]; then
                          exit 1
                      fi
                  fi
              done
          }

          ModifyCustomTemplate() {
              # Inserts the required "text" field to the custom json template from block kit builder.
              if [ "$(echo "$SLACK_PARAM_CUSTOM" | jq '.text')" = "null" ]; then
                  CUSTOM_BODY_MODIFIED=$(echo "$SLACK_PARAM_CUSTOM" | jq '. + {"text": ""}')
              else
                  # In case the text field was set manually.
                  CUSTOM_BODY_MODIFIED=$(echo "$SLACK_PARAM_CUSTOM" | jq '.')
              fi
          }

          InstallJq() {
              if uname -a | grep Darwin > /dev/null 2>&1; then
                  echo "Checking For JQ + CURL: MacOS"
                  command -v jq >/dev/null 2>&1 || HOMEBREW_NO_AUTO_UPDATE=1 brew install jq --quiet
                  return $?

              elif cat /etc/issue | grep Debian > /dev/null 2>&1 || cat /etc/issue | grep Ubuntu > /dev/null 2>&1; then
                  echo "Checking For JQ + CURL: Debian"
                  if [ "$(id -u)" = 0 ]; then export SUDO=""; else # Check if we're root
                      export SUDO="sudo";
                  fi
                  command -v jq >/dev/null 2>&1 || { $SUDO apt -qq update && $SUDO apt -qq install -y jq; }
                  return $?

              elif cat /etc/issue | grep Alpine > /dev/null 2>&1; then
                  echo "Checking For JQ + CURL: Alpine"
                  command -v curl >/dev/null 2>&1 || { echo >&2 "SLACK ORB ERROR: CURL is required. Please install."; exit 1; }
                  command -v jq >/dev/null 2>&1 || { echo >&2 "SLACK ORB ERROR: JQ is required. Please install"; exit 1; }
                  return $?
              fi
          }

          FilterBy() {
              if [ -z "$1" ] || [ -z "$2" ]; then
                return
              fi

              # If any pattern supplied matches the current branch or the current tag, proceed; otherwise, exit with message.
              FLAG_MATCHES_FILTER="false"
              for i in $(echo "$1" | sed "s/,/ /g")
              do
                  if echo "$2" | grep -Eq "^${i}$"; then
                      FLAG_MATCHES_FILTER="true"
                      break
                  fi
              done
              if [ "$FLAG_MATCHES_FILTER" = "false" ]; then
                  # dont send message.
                  echo "NO SLACK ALERT"
                  echo
                  echo "Current reference \"$2\" does not match any matching parameter"
                  echo "Current matching pattern: $1"
                  exit 0
              fi
          }

          CheckEnvVars() {
              if [ -z "$SLACK_ACCESS_TOKEN" ]; then
                  echo "In order to use the Slack Orb (v4 +), an OAuth token must be present via the SLACK_ACCESS_TOKEN environment variable."
                  echo "Follow the setup guide available in the wiki: https://github.com/CircleCI-Public/slack-orb/wiki/Setup"
                  exit 1
              fi
              # If no channel is provided, quit with error
              if [ -z "$SLACK_PARAM_CHANNEL" ]; then
                 echo "No channel was provided. Enter value for SLACK_DEFAULT_CHANNEL env var, or channel parameter"
                 exit 1
              fi
              if [ -n "$SLACK_WEBHOOK" ]; then
                  echo "It appears you have a Slack Webhook token present in this job."
                  echo "Please note, Webhooks are no longer used for the Slack Orb (v4 +)."
                  echo "Follow the setup guide available in the wiki: https://github.com/CircleCI-Public/slack-orb/wiki/Setup"
              fi
          }

          ShouldPost() {
              if [ "$CCI_STATUS" = "$SLACK_PARAM_EVENT" ] || [ "$SLACK_PARAM_EVENT" = "always" ]; then
                  # In the event the Slack notification would be sent, first ensure it is allowed to trigger
                  # on this branch or this tag.
                  FilterBy "$SLACK_PARAM_BRANCHPATTERN" "$CIRCLE_BRANCH"
                  FilterBy "$SLACK_PARAM_TAGPATTERN" "$CIRCLE_TAG"

                  echo "Posting Status"
              else
                  # dont send message.
                  echo "NO SLACK ALERT"
                  echo
                  echo "This command is set to send an alert on: $SLACK_PARAM_EVENT"
                  echo "Current status: ${CCI_STATUS}"
                  exit 0
              fi
          }

          # Will not run if sourced from another script.
          # This is done so this script may be tested.
          ORB_TEST_ENV="bats-core"
          if [ "${0#*$ORB_TEST_ENV}" = "$0" ]; then
              CheckEnvVars
              . "/tmp/SLACK_JOB_STATUS"
              ShouldPost
              InstallJq
              BuildMessageBody
              PostToSlack

          fi
        environment:
          SLACK_PARAM_BRANCHPATTERN: .+
          SLACK_PARAM_CHANNEL: $SLACK_DEFAULT_CHANNEL
          SLACK_PARAM_CUSTOM: ''
          SLACK_PARAM_EVENT: pass
          SLACK_PARAM_IGNORE_ERRORS: true
          SLACK_PARAM_MENTIONS: ''
          SLACK_PARAM_TAGPATTERN: .+
          SLACK_PARAM_TEMPLATE: basic_success_1
          basic_fail_1: "{\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"Job Failed. :red_circle:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Job*: ${CIRCLE_JOB}\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Branch*:\\\\n$CIRCLE_BRANCH\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Author*:\\\\n$CIRCLE_USERNAME\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Mentions*:\\\\n$SLACK_PARAM_MENTIONS\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Job\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"${CIRCLE_BUILD_URL}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}\n"
          basic_on_hold_1: "{\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"ON HOLD - Awaiting Approval :raised_hand:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Branch*:\\\\n$CIRCLE_BRANCH\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Author*:\\\\n$CIRCLE_USERNAME\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Mentions*:\\\\n$SLACK_PARAM_MENTIONS\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Workflow\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"https://circleci.com/workflow-run/${CIRCLE_WORKFLOW_ID}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}"
          basic_success_1: "{\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"Job Succeeded. :white_check_mark:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Job*: ${CIRCLE_JOB}\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Branch*:\\\\n$CIRCLE_BRANCH\"\n                },\n                {\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Commit*:\\\\n$CIRCLE_SHA1\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Author*:\\\\n$CIRCLE_USERNAME\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Job\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"${CIRCLE_BUILD_URL}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}\n"
          success_tagged_deploy_1: "{\n\t\"text\": \"\",\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"Deployment Successful! :tada:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*When*:\\\\n$(date +'%m/%d/%Y %T')\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Tag*:\\\\n$CIRCLE_TAG\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Job\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"${CIRCLE_BUILD_URL}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}"
        name: Slack - Sending Notification
        when: always
    - run:
        command: |
          echo 'export CCI_STATUS="fail"' > /tmp/SLACK_JOB_STATUS
        name: Slack - Detecting Job Status (FAIL)
        when: on_fail
    - run:
        command: |
          echo 'export CCI_STATUS="pass"' > /tmp/SLACK_JOB_STATUS
        name: Slack - Detecting Job Status (PASS)
        when: on_success
    - run:
        command: |
          BuildMessageBody() {
              # Send message
              #   If sending message, default to custom template,
              #   if none is supplied, check for a pre-selected template value.
              #   If none, error.
              if [ -n "$SLACK_PARAM_CUSTOM" ]; then
                  ModifyCustomTemplate
                  # shellcheck disable=SC2016
                  CUSTOM_BODY_MODIFIED=$(echo "$CUSTOM_BODY_MODIFIED" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed 's/`/\\`/g')
                  T2=$(eval echo \""$CUSTOM_BODY_MODIFIED"\")
              elif [ -n "$SLACK_PARAM_TEMPLATE" ]; then
                  TEMPLATE="\$$SLACK_PARAM_TEMPLATE"
                  T1=$(eval echo "$TEMPLATE" | sed 's/"/\\"/g')
                  T2=$(eval echo \""$T1"\")
              else
                  echo "Error: No message template selected."
                  echo "Select either a custom template or one of the pre-included ones via the 'custom' or 'template' parameters."
                  exit 1
              fi
              # Insert the default channel. THIS IS TEMPORARY
              T2=$(echo "$T2" | jq ". + {\"channel\": \"$SLACK_DEFAULT_CHANNEL\"}")
              SLACK_MSG_BODY=$T2
          }


          PostToSlack() {
              # Post once per channel listed by the channel parameter
              #    The channel must be modified in SLACK_MSG_BODY

              # shellcheck disable=SC2001
              for i in $(eval echo \""$SLACK_PARAM_CHANNEL"\" | sed "s/,/ /g")
              do
                  echo "Sending to Slack Channel: $i"
                  SLACK_MSG_BODY=$(echo "$SLACK_MSG_BODY" | jq --arg channel "$i" '.channel = $channel')
                  SLACK_SENT_RESPONSE=$(curl -s -f -X POST -H 'Content-type: application/json' -H "Authorization: Bearer $SLACK_ACCESS_TOKEN" --data "$SLACK_MSG_BODY" https://slack.com/api/chat.postMessage)
                  SLACK_ERROR_MSG=$(echo "$SLACK_SENT_RESPONSE" | jq '.error')
                  if [ ! "$SLACK_ERROR_MSG" = "null" ]; then
                      echo "Slack API returned an error message:"
                      echo "$SLACK_ERROR_MSG"
                      echo
                      echo
                      echo "View the Setup Guide: https://github.com/CircleCI-Public/slack-orb/wiki/Setup"
                      if [ "$SLACK_PARAM_IGNORE_ERRORS" = "0" ]; then
                          exit 1
                      fi
                  fi
              done
          }

          ModifyCustomTemplate() {
              # Inserts the required "text" field to the custom json template from block kit builder.
              if [ "$(echo "$SLACK_PARAM_CUSTOM" | jq '.text')" = "null" ]; then
                  CUSTOM_BODY_MODIFIED=$(echo "$SLACK_PARAM_CUSTOM" | jq '. + {"text": ""}')
              else
                  # In case the text field was set manually.
                  CUSTOM_BODY_MODIFIED=$(echo "$SLACK_PARAM_CUSTOM" | jq '.')
              fi
          }

          InstallJq() {
              if uname -a | grep Darwin > /dev/null 2>&1; then
                  echo "Checking For JQ + CURL: MacOS"
                  command -v jq >/dev/null 2>&1 || HOMEBREW_NO_AUTO_UPDATE=1 brew install jq --quiet
                  return $?

              elif cat /etc/issue | grep Debian > /dev/null 2>&1 || cat /etc/issue | grep Ubuntu > /dev/null 2>&1; then
                  echo "Checking For JQ + CURL: Debian"
                  if [ "$(id -u)" = 0 ]; then export SUDO=""; else # Check if we're root
                      export SUDO="sudo";
                  fi
                  command -v jq >/dev/null 2>&1 || { $SUDO apt -qq update && $SUDO apt -qq install -y jq; }
                  return $?

              elif cat /etc/issue | grep Alpine > /dev/null 2>&1; then
                  echo "Checking For JQ + CURL: Alpine"
                  command -v curl >/dev/null 2>&1 || { echo >&2 "SLACK ORB ERROR: CURL is required. Please install."; exit 1; }
                  command -v jq >/dev/null 2>&1 || { echo >&2 "SLACK ORB ERROR: JQ is required. Please install"; exit 1; }
                  return $?
              fi
          }

          FilterBy() {
              if [ -z "$1" ] || [ -z "$2" ]; then
                return
              fi

              # If any pattern supplied matches the current branch or the current tag, proceed; otherwise, exit with message.
              FLAG_MATCHES_FILTER="false"
              for i in $(echo "$1" | sed "s/,/ /g")
              do
                  if echo "$2" | grep -Eq "^${i}$"; then
                      FLAG_MATCHES_FILTER="true"
                      break
                  fi
              done
              if [ "$FLAG_MATCHES_FILTER" = "false" ]; then
                  # dont send message.
                  echo "NO SLACK ALERT"
                  echo
                  echo "Current reference \"$2\" does not match any matching parameter"
                  echo "Current matching pattern: $1"
                  exit 0
              fi
          }

          CheckEnvVars() {
              if [ -z "$SLACK_ACCESS_TOKEN" ]; then
                  echo "In order to use the Slack Orb (v4 +), an OAuth token must be present via the SLACK_ACCESS_TOKEN environment variable."
                  echo "Follow the setup guide available in the wiki: https://github.com/CircleCI-Public/slack-orb/wiki/Setup"
                  exit 1
              fi
              # If no channel is provided, quit with error
              if [ -z "$SLACK_PARAM_CHANNEL" ]; then
                 echo "No channel was provided. Enter value for SLACK_DEFAULT_CHANNEL env var, or channel parameter"
                 exit 1
              fi
              if [ -n "$SLACK_WEBHOOK" ]; then
                  echo "It appears you have a Slack Webhook token present in this job."
                  echo "Please note, Webhooks are no longer used for the Slack Orb (v4 +)."
                  echo "Follow the setup guide available in the wiki: https://github.com/CircleCI-Public/slack-orb/wiki/Setup"
              fi
          }

          ShouldPost() {
              if [ "$CCI_STATUS" = "$SLACK_PARAM_EVENT" ] || [ "$SLACK_PARAM_EVENT" = "always" ]; then
                  # In the event the Slack notification would be sent, first ensure it is allowed to trigger
                  # on this branch or this tag.
                  FilterBy "$SLACK_PARAM_BRANCHPATTERN" "$CIRCLE_BRANCH"
                  FilterBy "$SLACK_PARAM_TAGPATTERN" "$CIRCLE_TAG"

                  echo "Posting Status"
              else
                  # dont send message.
                  echo "NO SLACK ALERT"
                  echo
                  echo "This command is set to send an alert on: $SLACK_PARAM_EVENT"
                  echo "Current status: ${CCI_STATUS}"
                  exit 0
              fi
          }

          # Will not run if sourced from another script.
          # This is done so this script may be tested.
          ORB_TEST_ENV="bats-core"
          if [ "${0#*$ORB_TEST_ENV}" = "$0" ]; then
              CheckEnvVars
              . "/tmp/SLACK_JOB_STATUS"
              ShouldPost
              InstallJq
              BuildMessageBody
              PostToSlack

          fi
        environment:
          SLACK_PARAM_BRANCHPATTERN: .+
          SLACK_PARAM_CHANNEL: $SLACK_DEFAULT_CHANNEL
          SLACK_PARAM_CUSTOM: ''
          SLACK_PARAM_EVENT: fail
          SLACK_PARAM_IGNORE_ERRORS: true
          SLACK_PARAM_MENTIONS: ''
          SLACK_PARAM_TAGPATTERN: .+
          SLACK_PARAM_TEMPLATE: basic_on_hold_1
          basic_fail_1: "{\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"Job Failed. :red_circle:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Job*: ${CIRCLE_JOB}\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Branch*:\\\\n$CIRCLE_BRANCH\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Author*:\\\\n$CIRCLE_USERNAME\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Mentions*:\\\\n$SLACK_PARAM_MENTIONS\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Job\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"${CIRCLE_BUILD_URL}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}\n"
          basic_on_hold_1: "{\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"ON HOLD - Awaiting Approval :raised_hand:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Branch*:\\\\n$CIRCLE_BRANCH\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Author*:\\\\n$CIRCLE_USERNAME\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Mentions*:\\\\n$SLACK_PARAM_MENTIONS\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Workflow\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"https://circleci.com/workflow-run/${CIRCLE_WORKFLOW_ID}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}"
          basic_success_1: "{\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"Job Succeeded. :white_check_mark:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Job*: ${CIRCLE_JOB}\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Branch*:\\\\n$CIRCLE_BRANCH\"\n                },\n                {\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Commit*:\\\\n$CIRCLE_SHA1\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Author*:\\\\n$CIRCLE_USERNAME\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Job\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"${CIRCLE_BUILD_URL}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}\n"
          success_tagged_deploy_1: "{\n\t\"text\": \"\",\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"Deployment Successful! :tada:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*When*:\\\\n$(date +'%m/%d/%Y %T')\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Tag*:\\\\n$CIRCLE_TAG\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Job\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"${CIRCLE_BUILD_URL}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}"
        name: Slack - Sending Notification
        when: always
  build_and_test:
    machine:
      image: windows-server-2019-vs2019:stable
    steps:
    - checkout
    - run:
        name: Pull Submodules for Development
        command: |
          git submodule init
          git submodule update --remote
          cd eldmandate-data-layer
          git config --global user.email "circle@circle"
          git config --global user.name "circleci"
          git checkout develop
          git pull origin develop
          cd ..
    - restore_cache:
        keys:
        - dotnet-packages-v1-{{ checksum "IntegrationTests/IntegrationTests.csproj" }}
    - run:
        name: Build
        command: dotnet build assettracker.api.microservice.sln
    - save_cache:
        paths:
        - C:\Users\circleci\.nuget\packages
        key: dotnet-packages-v1-{{ checksum "IntegrationTests/IntegrationTests.csproj" }}
    - run:
        name: Install Test Coverage tool ReportGenerator
        command: |
          dotnet tool install -g dotnet-reportgenerator-globaltool
          dotnet tool install dotnet-reportgenerator-globaltool --tool-path tools
          dotnet new tool-manifest
          dotnet tool install dotnet-reportgenerator-globaltool
    - run:
        name: Run Integration Tests
        command: |
          cd IntegrationTests
          dotnet test --results-directory:test_coverage --collect:"Xplat Code Coverage" --settings coverlet.runsettings
    - run:
        name: Create xUnit Report
        command: |
          cd IntegrationTests/test_coverage/*
          reportgenerator "-reports:*.xml" "-targetdir:report"
    - store_artifacts:
        path: C:\Users\circleci\project\IntegrationTests\test_coverage
    - run:
        name: Check test coverage. Fail below coverage minimums.
        command: |
          $intCoverageXML = [xml](Get-Content C:\Users\circleci\project\IntegrationTests\test_coverage\*\coverage.cobertura.xml)
          [decimal]$intLineCoverage=$intCoverageXML.coverage | Select -ExpandProperty line-rate
          [decimal]$intBranchCoverage=$intCoverageXML.coverage | Select -ExpandProperty branch-rate
          echo "LINE COVERAGE: $intLineCoverage"
          echo "BRANCH COVERAGE: $intBranchCoverage"
          if (($intLineCoverage -ge 0.05) -and ($intBranchCoverage -ge .05)) {
            Exit 0
          }
          else {
            Exit 1
          }
    resource_class: windows.medium
    shell: powershell.exe -ExecutionPolicy Bypass
  deployment-prod-build-notify:
    docker:
    - image: cimg/node:14.15.1-browsers
    steps:
    - run:
        name: Prepare Template
        when: always
        command: |
          SHORT_SHA1=`echo -n $CIRCLE_SHA1 | head -c 7`

          if [ `echo "$CIRCLE_REPOSITORY_URL" | grep "^git@github.com"` ]; then
            COMMIT_LINK=\[$SHORT_SHA1\]\(https://github.com/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/commit/$CIRCLE_SHA1\)
          elif [ `echo "$CIRCLE_REPOSITORY_URL" | grep "^git@bitbucket.org"` ]; then
            COMMIT_LINK=\[$SHORT_SHA1\]\(https://bitbucket.org/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/commit/$CIRCLE_SHA1\)
          else
            >&2 echo unknown version control system: $CIRCLE_REPOSITORY_URL
            fail
          fi

          # Note that the "<<" in the heredoc declaration is escaped from
          # CircleCI's parameters syntax.
          MS_TEAMS_MSG_TEMPLATE=$(cat <<END_HEREDOC
          {
            "@type": "MessageCard",
            "@context": "http://schema.org/extensions",
            "themeCdocker_jobolor": "__theme_color__",
            "summary": "CircleCI Build Notification",
            "sections": [
              {
                "activityTitle": "__build_status__: $CIRCLE_PROJECT_REPONAME job [${CIRCLE_JOB} #${CIRCLE_BUILD_NUM}]($CIRCLE_BUILD_URL)",
                "facts": [
                  {
                    "name": "Git ref",
                    "value": "$CIRCLE_BRANCH $CIRCLE_TAG"
                  },
                  {
                    "name": "Commit",
                    "value": "$COMMIT_LINK"
                  }
                ],
                "markdown": true
              }
            ]
          }
          END_HEREDOC
          )
          echo "$MS_TEAMS_MSG_TEMPLATE" > /tmp/ms_teams_message
    - run:
        name: Report Build Success
        command: |
          MSG_PATH=/tmp/ms_teams_success_message
          sed -e 's/__build_status__/Success/' -e 's/__theme_color__/14a603/' \
              /tmp/ms_teams_message > $MSG_PATH
          curl --fail -H "Content-Type: application/json" \
                --data-binary @$MSG_PATH \
                https://eldmandate.webhook.office.com/webhookb2/37002470-5070-4f01-b6ed-3bcc44180824@6a4f939d-635f-454d-9d19-7926a1208c06/IncomingWebhook/aae189ec52a04f04bd7d2c6e8271461d/aea37b94-7ffa-42b8-9cbe-014d0a48e677
        when: on_success
    - run:
        name: Report Build Failure
        command: |
          MSG_PATH=/tmp/ms_teams_failure_message
          sed -e 's/__build_status__/Failed/' -e 's/__theme_color__/e2091d/' \
              /tmp/ms_teams_message > $MSG_PATH
          curl --fail -H "Content-Type: application/json" \
                --data-binary @$MSG_PATH \
                https://eldmandate.webhook.office.com/webhookb2/37002470-5070-4f01-b6ed-3bcc44180824@6a4f939d-635f-454d-9d19-7926a1208c06/IncomingWebhook/aae189ec52a04f04bd7d2c6e8271461d/aea37b94-7ffa-42b8-9cbe-014d0a48e677
        when: on_fail
  build_and_push_dev:
    machine: true
    steps:
    - checkout
    - run:
        name: Pull Submodules for Development
        command: |
          git submodule init
          git submodule update --remote
          cd eldmandate-data-layer
          git config --global user.email "circle@circle"
          git config --global user.name "circleci"
          git checkout develop
          git pull origin develop
          cd ..
    - run:
        command: |
          echo 'export CCI_STATUS="fail"' > /tmp/SLACK_JOB_STATUS
        name: Slack - Detecting Job Status (FAIL)
        when: on_fail
    - run:
        command: |
          echo 'export CCI_STATUS="pass"' > /tmp/SLACK_JOB_STATUS
        name: Slack - Detecting Job Status (PASS)
        when: on_success
    - run:
        command: |
          BuildMessageBody() {
              # Send message
              #   If sending message, default to custom template,
              #   if none is supplied, check for a pre-selected template value.
              #   If none, error.
              if [ -n "$SLACK_PARAM_CUSTOM" ]; then
                  ModifyCustomTemplate
                  # shellcheck disable=SC2016
                  CUSTOM_BODY_MODIFIED=$(echo "$CUSTOM_BODY_MODIFIED" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed 's/`/\\`/g')
                  T2=$(eval echo \""$CUSTOM_BODY_MODIFIED"\")
              elif [ -n "$SLACK_PARAM_TEMPLATE" ]; then
                  TEMPLATE="\$$SLACK_PARAM_TEMPLATE"
                  T1=$(eval echo "$TEMPLATE" | sed 's/"/\\"/g')
                  T2=$(eval echo \""$T1"\")
              else
                  echo "Error: No message template selected."
                  echo "Select either a custom template or one of the pre-included ones via the 'custom' or 'template' parameters."
                  exit 1
              fi
              # Insert the default channel. THIS IS TEMPORARY
              T2=$(echo "$T2" | jq ". + {\"channel\": \"$SLACK_DEFAULT_CHANNEL\"}")
              SLACK_MSG_BODY=$T2
          }


          PostToSlack() {
              # Post once per channel listed by the channel parameter
              #    The channel must be modified in SLACK_MSG_BODY

              # shellcheck disable=SC2001
              for i in $(eval echo \""$SLACK_PARAM_CHANNEL"\" | sed "s/,/ /g")
              do
                  echo "Sending to Slack Channel: $i"
                  SLACK_MSG_BODY=$(echo "$SLACK_MSG_BODY" | jq --arg channel "$i" '.channel = $channel')
                  SLACK_SENT_RESPONSE=$(curl -s -f -X POST -H 'Content-type: application/json' -H "Authorization: Bearer $SLACK_ACCESS_TOKEN" --data "$SLACK_MSG_BODY" https://slack.com/api/chat.postMessage)
                  SLACK_ERROR_MSG=$(echo "$SLACK_SENT_RESPONSE" | jq '.error')
                  if [ ! "$SLACK_ERROR_MSG" = "null" ]; then
                      echo "Slack API returned an error message:"
                      echo "$SLACK_ERROR_MSG"
                      echo
                      echo
                      echo "View the Setup Guide: https://github.com/CircleCI-Public/slack-orb/wiki/Setup"
                      if [ "$SLACK_PARAM_IGNORE_ERRORS" = "0" ]; then
                          exit 1
                      fi
                  fi
              done
          }

          ModifyCustomTemplate() {
              # Inserts the required "text" field to the custom json template from block kit builder.
              if [ "$(echo "$SLACK_PARAM_CUSTOM" | jq '.text')" = "null" ]; then
                  CUSTOM_BODY_MODIFIED=$(echo "$SLACK_PARAM_CUSTOM" | jq '. + {"text": ""}')
              else
                  # In case the text field was set manually.
                  CUSTOM_BODY_MODIFIED=$(echo "$SLACK_PARAM_CUSTOM" | jq '.')
              fi
          }

          InstallJq() {
              if uname -a | grep Darwin > /dev/null 2>&1; then
                  echo "Checking For JQ + CURL: MacOS"
                  command -v jq >/dev/null 2>&1 || HOMEBREW_NO_AUTO_UPDATE=1 brew install jq --quiet
                  return $?

              elif cat /etc/issue | grep Debian > /dev/null 2>&1 || cat /etc/issue | grep Ubuntu > /dev/null 2>&1; then
                  echo "Checking For JQ + CURL: Debian"
                  if [ "$(id -u)" = 0 ]; then export SUDO=""; else # Check if we're root
                      export SUDO="sudo";
                  fi
                  command -v jq >/dev/null 2>&1 || { $SUDO apt -qq update && $SUDO apt -qq install -y jq; }
                  return $?

              elif cat /etc/issue | grep Alpine > /dev/null 2>&1; then
                  echo "Checking For JQ + CURL: Alpine"
                  command -v curl >/dev/null 2>&1 || { echo >&2 "SLACK ORB ERROR: CURL is required. Please install."; exit 1; }
                  command -v jq >/dev/null 2>&1 || { echo >&2 "SLACK ORB ERROR: JQ is required. Please install"; exit 1; }
                  return $?
              fi
          }

          FilterBy() {
              if [ -z "$1" ] || [ -z "$2" ]; then
                return
              fi

              # If any pattern supplied matches the current branch or the current tag, proceed; otherwise, exit with message.
              FLAG_MATCHES_FILTER="false"
              for i in $(echo "$1" | sed "s/,/ /g")
              do
                  if echo "$2" | grep -Eq "^${i}$"; then
                      FLAG_MATCHES_FILTER="true"
                      break
                  fi
              done
              if [ "$FLAG_MATCHES_FILTER" = "false" ]; then
                  # dont send message.
                  echo "NO SLACK ALERT"
                  echo
                  echo "Current reference \"$2\" does not match any matching parameter"
                  echo "Current matching pattern: $1"
                  exit 0
              fi
          }

          CheckEnvVars() {
              if [ -z "$SLACK_ACCESS_TOKEN" ]; then
                  echo "In order to use the Slack Orb (v4 +), an OAuth token must be present via the SLACK_ACCESS_TOKEN environment variable."
                  echo "Follow the setup guide available in the wiki: https://github.com/CircleCI-Public/slack-orb/wiki/Setup"
                  exit 1
              fi
              # If no channel is provided, quit with error
              if [ -z "$SLACK_PARAM_CHANNEL" ]; then
                 echo "No channel was provided. Enter value for SLACK_DEFAULT_CHANNEL env var, or channel parameter"
                 exit 1
              fi
              if [ -n "$SLACK_WEBHOOK" ]; then
                  echo "It appears you have a Slack Webhook token present in this job."
                  echo "Please note, Webhooks are no longer used for the Slack Orb (v4 +)."
                  echo "Follow the setup guide available in the wiki: https://github.com/CircleCI-Public/slack-orb/wiki/Setup"
              fi
          }

          ShouldPost() {
              if [ "$CCI_STATUS" = "$SLACK_PARAM_EVENT" ] || [ "$SLACK_PARAM_EVENT" = "always" ]; then
                  # In the event the Slack notification would be sent, first ensure it is allowed to trigger
                  # on this branch or this tag.
                  FilterBy "$SLACK_PARAM_BRANCHPATTERN" "$CIRCLE_BRANCH"
                  FilterBy "$SLACK_PARAM_TAGPATTERN" "$CIRCLE_TAG"

                  echo "Posting Status"
              else
                  # dont send message.
                  echo "NO SLACK ALERT"
                  echo
                  echo "This command is set to send an alert on: $SLACK_PARAM_EVENT"
                  echo "Current status: ${CCI_STATUS}"
                  exit 0
              fi
          }

          # Will not run if sourced from another script.
          # This is done so this script may be tested.
          ORB_TEST_ENV="bats-core"
          if [ "${0#*$ORB_TEST_ENV}" = "$0" ]; then
              CheckEnvVars
              . "/tmp/SLACK_JOB_STATUS"
              ShouldPost
              InstallJq
              BuildMessageBody
              PostToSlack

          fi
        environment:
          SLACK_PARAM_BRANCHPATTERN: .+
          SLACK_PARAM_CHANNEL: $SLACK_DEFAULT_CHANNEL
          SLACK_PARAM_CUSTOM: ''
          SLACK_PARAM_EVENT: fail
          SLACK_PARAM_IGNORE_ERRORS: true
          SLACK_PARAM_MENTIONS: ''
          SLACK_PARAM_TAGPATTERN: .+
          SLACK_PARAM_TEMPLATE: basic_fail_1
          basic_fail_1: "{\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"Job Failed. :red_circle:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Job*: ${CIRCLE_JOB}\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Branch*:\\\\n$CIRCLE_BRANCH\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Author*:\\\\n$CIRCLE_USERNAME\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Mentions*:\\\\n$SLACK_PARAM_MENTIONS\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Job\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"${CIRCLE_BUILD_URL}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}\n"
          basic_on_hold_1: "{\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"ON HOLD - Awaiting Approval :raised_hand:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Branch*:\\\\n$CIRCLE_BRANCH\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Author*:\\\\n$CIRCLE_USERNAME\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Mentions*:\\\\n$SLACK_PARAM_MENTIONS\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Workflow\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"https://circleci.com/workflow-run/${CIRCLE_WORKFLOW_ID}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}"
          basic_success_1: "{\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"Job Succeeded. :white_check_mark:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Job*: ${CIRCLE_JOB}\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Branch*:\\\\n$CIRCLE_BRANCH\"\n                },\n                {\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Commit*:\\\\n$CIRCLE_SHA1\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Author*:\\\\n$CIRCLE_USERNAME\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Job\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"${CIRCLE_BUILD_URL}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}\n"
          success_tagged_deploy_1: "{\n\t\"text\": \"\",\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"Deployment Successful! :tada:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*When*:\\\\n$(date +'%m/%d/%Y %T')\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Tag*:\\\\n$CIRCLE_TAG\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Job\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"${CIRCLE_BUILD_URL}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}"
        name: Slack - Sending Notification
        when: always
    - run:
        command: |
          echo 'export CCI_STATUS="fail"' > /tmp/SLACK_JOB_STATUS
        name: Slack - Detecting Job Status (FAIL)
        when: on_fail
    - run:
        command: |
          echo 'export CCI_STATUS="pass"' > /tmp/SLACK_JOB_STATUS
        name: Slack - Detecting Job Status (PASS)
        when: on_success
    - run:
        command: |
          BuildMessageBody() {
              # Send message
              #   If sending message, default to custom template,
              #   if none is supplied, check for a pre-selected template value.
              #   If none, error.
              if [ -n "$SLACK_PARAM_CUSTOM" ]; then
                  ModifyCustomTemplate
                  # shellcheck disable=SC2016
                  CUSTOM_BODY_MODIFIED=$(echo "$CUSTOM_BODY_MODIFIED" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed 's/`/\\`/g')
                  T2=$(eval echo \""$CUSTOM_BODY_MODIFIED"\")
              elif [ -n "$SLACK_PARAM_TEMPLATE" ]; then
                  TEMPLATE="\$$SLACK_PARAM_TEMPLATE"
                  T1=$(eval echo "$TEMPLATE" | sed 's/"/\\"/g')
                  T2=$(eval echo \""$T1"\")
              else
                  echo "Error: No message template selected."
                  echo "Select either a custom template or one of the pre-included ones via the 'custom' or 'template' parameters."
                  exit 1
              fi
              # Insert the default channel. THIS IS TEMPORARY
              T2=$(echo "$T2" | jq ". + {\"channel\": \"$SLACK_DEFAULT_CHANNEL\"}")
              SLACK_MSG_BODY=$T2
          }


          PostToSlack() {
              # Post once per channel listed by the channel parameter
              #    The channel must be modified in SLACK_MSG_BODY

              # shellcheck disable=SC2001
              for i in $(eval echo \""$SLACK_PARAM_CHANNEL"\" | sed "s/,/ /g")
              do
                  echo "Sending to Slack Channel: $i"
                  SLACK_MSG_BODY=$(echo "$SLACK_MSG_BODY" | jq --arg channel "$i" '.channel = $channel')
                  SLACK_SENT_RESPONSE=$(curl -s -f -X POST -H 'Content-type: application/json' -H "Authorization: Bearer $SLACK_ACCESS_TOKEN" --data "$SLACK_MSG_BODY" https://slack.com/api/chat.postMessage)
                  SLACK_ERROR_MSG=$(echo "$SLACK_SENT_RESPONSE" | jq '.error')
                  if [ ! "$SLACK_ERROR_MSG" = "null" ]; then
                      echo "Slack API returned an error message:"
                      echo "$SLACK_ERROR_MSG"
                      echo
                      echo
                      echo "View the Setup Guide: https://github.com/CircleCI-Public/slack-orb/wiki/Setup"
                      if [ "$SLACK_PARAM_IGNORE_ERRORS" = "0" ]; then
                          exit 1
                      fi
                  fi
              done
          }

          ModifyCustomTemplate() {
              # Inserts the required "text" field to the custom json template from block kit builder.
              if [ "$(echo "$SLACK_PARAM_CUSTOM" | jq '.text')" = "null" ]; then
                  CUSTOM_BODY_MODIFIED=$(echo "$SLACK_PARAM_CUSTOM" | jq '. + {"text": ""}')
              else
                  # In case the text field was set manually.
                  CUSTOM_BODY_MODIFIED=$(echo "$SLACK_PARAM_CUSTOM" | jq '.')
              fi
          }

          InstallJq() {
              if uname -a | grep Darwin > /dev/null 2>&1; then
                  echo "Checking For JQ + CURL: MacOS"
                  command -v jq >/dev/null 2>&1 || HOMEBREW_NO_AUTO_UPDATE=1 brew install jq --quiet
                  return $?

              elif cat /etc/issue | grep Debian > /dev/null 2>&1 || cat /etc/issue | grep Ubuntu > /dev/null 2>&1; then
                  echo "Checking For JQ + CURL: Debian"
                  if [ "$(id -u)" = 0 ]; then export SUDO=""; else # Check if we're root
                      export SUDO="sudo";
                  fi
                  command -v jq >/dev/null 2>&1 || { $SUDO apt -qq update && $SUDO apt -qq install -y jq; }
                  return $?

              elif cat /etc/issue | grep Alpine > /dev/null 2>&1; then
                  echo "Checking For JQ + CURL: Alpine"
                  command -v curl >/dev/null 2>&1 || { echo >&2 "SLACK ORB ERROR: CURL is required. Please install."; exit 1; }
                  command -v jq >/dev/null 2>&1 || { echo >&2 "SLACK ORB ERROR: JQ is required. Please install"; exit 1; }
                  return $?
              fi
          }

          FilterBy() {
              if [ -z "$1" ] || [ -z "$2" ]; then
                return
              fi

              # If any pattern supplied matches the current branch or the current tag, proceed; otherwise, exit with message.
              FLAG_MATCHES_FILTER="false"
              for i in $(echo "$1" | sed "s/,/ /g")
              do
                  if echo "$2" | grep -Eq "^${i}$"; then
                      FLAG_MATCHES_FILTER="true"
                      break
                  fi
              done
              if [ "$FLAG_MATCHES_FILTER" = "false" ]; then
                  # dont send message.
                  echo "NO SLACK ALERT"
                  echo
                  echo "Current reference \"$2\" does not match any matching parameter"
                  echo "Current matching pattern: $1"
                  exit 0
              fi
          }

          CheckEnvVars() {
              if [ -z "$SLACK_ACCESS_TOKEN" ]; then
                  echo "In order to use the Slack Orb (v4 +), an OAuth token must be present via the SLACK_ACCESS_TOKEN environment variable."
                  echo "Follow the setup guide available in the wiki: https://github.com/CircleCI-Public/slack-orb/wiki/Setup"
                  exit 1
              fi
              # If no channel is provided, quit with error
              if [ -z "$SLACK_PARAM_CHANNEL" ]; then
                 echo "No channel was provided. Enter value for SLACK_DEFAULT_CHANNEL env var, or channel parameter"
                 exit 1
              fi
              if [ -n "$SLACK_WEBHOOK" ]; then
                  echo "It appears you have a Slack Webhook token present in this job."
                  echo "Please note, Webhooks are no longer used for the Slack Orb (v4 +)."
                  echo "Follow the setup guide available in the wiki: https://github.com/CircleCI-Public/slack-orb/wiki/Setup"
              fi
          }

          ShouldPost() {
              if [ "$CCI_STATUS" = "$SLACK_PARAM_EVENT" ] || [ "$SLACK_PARAM_EVENT" = "always" ]; then
                  # In the event the Slack notification would be sent, first ensure it is allowed to trigger
                  # on this branch or this tag.
                  FilterBy "$SLACK_PARAM_BRANCHPATTERN" "$CIRCLE_BRANCH"
                  FilterBy "$SLACK_PARAM_TAGPATTERN" "$CIRCLE_TAG"

                  echo "Posting Status"
              else
                  # dont send message.
                  echo "NO SLACK ALERT"
                  echo
                  echo "This command is set to send an alert on: $SLACK_PARAM_EVENT"
                  echo "Current status: ${CCI_STATUS}"
                  exit 0
              fi
          }

          # Will not run if sourced from another script.
          # This is done so this script may be tested.
          ORB_TEST_ENV="bats-core"
          if [ "${0#*$ORB_TEST_ENV}" = "$0" ]; then
              CheckEnvVars
              . "/tmp/SLACK_JOB_STATUS"
              ShouldPost
              InstallJq
              BuildMessageBody
              PostToSlack

          fi
        environment:
          SLACK_PARAM_BRANCHPATTERN: .+
          SLACK_PARAM_CHANNEL: $SLACK_DEFAULT_CHANNEL
          SLACK_PARAM_CUSTOM: ''
          SLACK_PARAM_EVENT: pass
          SLACK_PARAM_IGNORE_ERRORS: true
          SLACK_PARAM_MENTIONS: ''
          SLACK_PARAM_TAGPATTERN: .+
          SLACK_PARAM_TEMPLATE: basic_success_1
          basic_fail_1: "{\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"Job Failed. :red_circle:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Job*: ${CIRCLE_JOB}\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Branch*:\\\\n$CIRCLE_BRANCH\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Author*:\\\\n$CIRCLE_USERNAME\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Mentions*:\\\\n$SLACK_PARAM_MENTIONS\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Job\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"${CIRCLE_BUILD_URL}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}\n"
          basic_on_hold_1: "{\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"ON HOLD - Awaiting Approval :raised_hand:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Branch*:\\\\n$CIRCLE_BRANCH\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Author*:\\\\n$CIRCLE_USERNAME\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Mentions*:\\\\n$SLACK_PARAM_MENTIONS\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Workflow\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"https://circleci.com/workflow-run/${CIRCLE_WORKFLOW_ID}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}"
          basic_success_1: "{\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"Job Succeeded. :white_check_mark:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Job*: ${CIRCLE_JOB}\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Branch*:\\\\n$CIRCLE_BRANCH\"\n                },\n                {\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Commit*:\\\\n$CIRCLE_SHA1\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Author*:\\\\n$CIRCLE_USERNAME\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Job\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"${CIRCLE_BUILD_URL}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}\n"
          success_tagged_deploy_1: "{\n\t\"text\": \"\",\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"Deployment Successful! :tada:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*When*:\\\\n$(date +'%m/%d/%Y %T')\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Tag*:\\\\n$CIRCLE_TAG\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Job\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"${CIRCLE_BUILD_URL}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}"
        name: Slack - Sending Notification
        when: always
    - run:
        command: |
          echo 'export CCI_STATUS="fail"' > /tmp/SLACK_JOB_STATUS
        name: Slack - Detecting Job Status (FAIL)
        when: on_fail
    - run:
        command: |
          echo 'export CCI_STATUS="pass"' > /tmp/SLACK_JOB_STATUS
        name: Slack - Detecting Job Status (PASS)
        when: on_success
    - run:
        command: |
          BuildMessageBody() {
              # Send message
              #   If sending message, default to custom template,
              #   if none is supplied, check for a pre-selected template value.
              #   If none, error.
              if [ -n "$SLACK_PARAM_CUSTOM" ]; then
                  ModifyCustomTemplate
                  # shellcheck disable=SC2016
                  CUSTOM_BODY_MODIFIED=$(echo "$CUSTOM_BODY_MODIFIED" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed 's/`/\\`/g')
                  T2=$(eval echo \""$CUSTOM_BODY_MODIFIED"\")
              elif [ -n "$SLACK_PARAM_TEMPLATE" ]; then
                  TEMPLATE="\$$SLACK_PARAM_TEMPLATE"
                  T1=$(eval echo "$TEMPLATE" | sed 's/"/\\"/g')
                  T2=$(eval echo \""$T1"\")
              else
                  echo "Error: No message template selected."
                  echo "Select either a custom template or one of the pre-included ones via the 'custom' or 'template' parameters."
                  exit 1
              fi
              # Insert the default channel. THIS IS TEMPORARY
              T2=$(echo "$T2" | jq ". + {\"channel\": \"$SLACK_DEFAULT_CHANNEL\"}")
              SLACK_MSG_BODY=$T2
          }


          PostToSlack() {
              # Post once per channel listed by the channel parameter
              #    The channel must be modified in SLACK_MSG_BODY

              # shellcheck disable=SC2001
              for i in $(eval echo \""$SLACK_PARAM_CHANNEL"\" | sed "s/,/ /g")
              do
                  echo "Sending to Slack Channel: $i"
                  SLACK_MSG_BODY=$(echo "$SLACK_MSG_BODY" | jq --arg channel "$i" '.channel = $channel')
                  SLACK_SENT_RESPONSE=$(curl -s -f -X POST -H 'Content-type: application/json' -H "Authorization: Bearer $SLACK_ACCESS_TOKEN" --data "$SLACK_MSG_BODY" https://slack.com/api/chat.postMessage)
                  SLACK_ERROR_MSG=$(echo "$SLACK_SENT_RESPONSE" | jq '.error')
                  if [ ! "$SLACK_ERROR_MSG" = "null" ]; then
                      echo "Slack API returned an error message:"
                      echo "$SLACK_ERROR_MSG"
                      echo
                      echo
                      echo "View the Setup Guide: https://github.com/CircleCI-Public/slack-orb/wiki/Setup"
                      if [ "$SLACK_PARAM_IGNORE_ERRORS" = "0" ]; then
                          exit 1
                      fi
                  fi
              done
          }

          ModifyCustomTemplate() {
              # Inserts the required "text" field to the custom json template from block kit builder.
              if [ "$(echo "$SLACK_PARAM_CUSTOM" | jq '.text')" = "null" ]; then
                  CUSTOM_BODY_MODIFIED=$(echo "$SLACK_PARAM_CUSTOM" | jq '. + {"text": ""}')
              else
                  # In case the text field was set manually.
                  CUSTOM_BODY_MODIFIED=$(echo "$SLACK_PARAM_CUSTOM" | jq '.')
              fi
          }

          InstallJq() {
              if uname -a | grep Darwin > /dev/null 2>&1; then
                  echo "Checking For JQ + CURL: MacOS"
                  command -v jq >/dev/null 2>&1 || HOMEBREW_NO_AUTO_UPDATE=1 brew install jq --quiet
                  return $?

              elif cat /etc/issue | grep Debian > /dev/null 2>&1 || cat /etc/issue | grep Ubuntu > /dev/null 2>&1; then
                  echo "Checking For JQ + CURL: Debian"
                  if [ "$(id -u)" = 0 ]; then export SUDO=""; else # Check if we're root
                      export SUDO="sudo";
                  fi
                  command -v jq >/dev/null 2>&1 || { $SUDO apt -qq update && $SUDO apt -qq install -y jq; }
                  return $?

              elif cat /etc/issue | grep Alpine > /dev/null 2>&1; then
                  echo "Checking For JQ + CURL: Alpine"
                  command -v curl >/dev/null 2>&1 || { echo >&2 "SLACK ORB ERROR: CURL is required. Please install."; exit 1; }
                  command -v jq >/dev/null 2>&1 || { echo >&2 "SLACK ORB ERROR: JQ is required. Please install"; exit 1; }
                  return $?
              fi
          }

          FilterBy() {
              if [ -z "$1" ] || [ -z "$2" ]; then
                return
              fi

              # If any pattern supplied matches the current branch or the current tag, proceed; otherwise, exit with message.
              FLAG_MATCHES_FILTER="false"
              for i in $(echo "$1" | sed "s/,/ /g")
              do
                  if echo "$2" | grep -Eq "^${i}$"; then
                      FLAG_MATCHES_FILTER="true"
                      break
                  fi
              done
              if [ "$FLAG_MATCHES_FILTER" = "false" ]; then
                  # dont send message.
                  echo "NO SLACK ALERT"
                  echo
                  echo "Current reference \"$2\" does not match any matching parameter"
                  echo "Current matching pattern: $1"
                  exit 0
              fi
          }

          CheckEnvVars() {
              if [ -z "$SLACK_ACCESS_TOKEN" ]; then
                  echo "In order to use the Slack Orb (v4 +), an OAuth token must be present via the SLACK_ACCESS_TOKEN environment variable."
                  echo "Follow the setup guide available in the wiki: https://github.com/CircleCI-Public/slack-orb/wiki/Setup"
                  exit 1
              fi
              # If no channel is provided, quit with error
              if [ -z "$SLACK_PARAM_CHANNEL" ]; then
                 echo "No channel was provided. Enter value for SLACK_DEFAULT_CHANNEL env var, or channel parameter"
                 exit 1
              fi
              if [ -n "$SLACK_WEBHOOK" ]; then
                  echo "It appears you have a Slack Webhook token present in this job."
                  echo "Please note, Webhooks are no longer used for the Slack Orb (v4 +)."
                  echo "Follow the setup guide available in the wiki: https://github.com/CircleCI-Public/slack-orb/wiki/Setup"
              fi
          }

          ShouldPost() {
              if [ "$CCI_STATUS" = "$SLACK_PARAM_EVENT" ] || [ "$SLACK_PARAM_EVENT" = "always" ]; then
                  # In the event the Slack notification would be sent, first ensure it is allowed to trigger
                  # on this branch or this tag.
                  FilterBy "$SLACK_PARAM_BRANCHPATTERN" "$CIRCLE_BRANCH"
                  FilterBy "$SLACK_PARAM_TAGPATTERN" "$CIRCLE_TAG"

                  echo "Posting Status"
              else
                  # dont send message.
                  echo "NO SLACK ALERT"
                  echo
                  echo "This command is set to send an alert on: $SLACK_PARAM_EVENT"
                  echo "Current status: ${CCI_STATUS}"
                  exit 0
              fi
          }

          # Will not run if sourced from another script.
          # This is done so this script may be tested.
          ORB_TEST_ENV="bats-core"
          if [ "${0#*$ORB_TEST_ENV}" = "$0" ]; then
              CheckEnvVars
              . "/tmp/SLACK_JOB_STATUS"
              ShouldPost
              InstallJq
              BuildMessageBody
              PostToSlack

          fi
        environment:
          SLACK_PARAM_BRANCHPATTERN: .+
          SLACK_PARAM_CHANNEL: $SLACK_DEFAULT_CHANNEL
          SLACK_PARAM_CUSTOM: ''
          SLACK_PARAM_EVENT: fail
          SLACK_PARAM_IGNORE_ERRORS: true
          SLACK_PARAM_MENTIONS: ''
          SLACK_PARAM_TAGPATTERN: .+
          SLACK_PARAM_TEMPLATE: basic_on_hold_1
          basic_fail_1: "{\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"Job Failed. :red_circle:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Job*: ${CIRCLE_JOB}\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Branch*:\\\\n$CIRCLE_BRANCH\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Author*:\\\\n$CIRCLE_USERNAME\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Mentions*:\\\\n$SLACK_PARAM_MENTIONS\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Job\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"${CIRCLE_BUILD_URL}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}\n"
          basic_on_hold_1: "{\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"ON HOLD - Awaiting Approval :raised_hand:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Branch*:\\\\n$CIRCLE_BRANCH\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Author*:\\\\n$CIRCLE_USERNAME\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Mentions*:\\\\n$SLACK_PARAM_MENTIONS\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Workflow\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"https://circleci.com/workflow-run/${CIRCLE_WORKFLOW_ID}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}"
          basic_success_1: "{\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"Job Succeeded. :white_check_mark:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Job*: ${CIRCLE_JOB}\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Branch*:\\\\n$CIRCLE_BRANCH\"\n                },\n                {\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Commit*:\\\\n$CIRCLE_SHA1\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Author*:\\\\n$CIRCLE_USERNAME\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Job\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"${CIRCLE_BUILD_URL}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}\n"
          success_tagged_deploy_1: "{\n\t\"text\": \"\",\n\t\"blocks\": [\n\t\t{\n\t\t\t\"type\": \"header\",\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"Deployment Successful! :tada:\",\n\t\t\t\t\"emoji\": true\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"section\",\n\t\t\t\"fields\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Project*:\\\\n$CIRCLE_PROJECT_REPONAME\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*When*:\\\\n$(date +'%m/%d/%Y %T')\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"mrkdwn\",\n\t\t\t\t\t\"text\": \"*Tag*:\\\\n$CIRCLE_TAG\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"accessory\": {\n\t\t\t\t\"type\": \"image\",\n\t\t\t\t\"image_url\": \"https://assets.brandfolder.com/otz5mn-bw4j2w-6jzqo8/original/circle-logo-badge-black.png\",\n\t\t\t\t\"alt_text\": \"CircleCI logo\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"actions\",\n\t\t\t\"elements\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"button\",\n\t\t\t\t\t\"text\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"View Job\"\n\t\t\t\t\t},\n\t\t\t\t\t\"url\": \"${CIRCLE_BUILD_URL}\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}"
        name: Slack - Sending Notification
        when: always
    - checkout
    - run:
        command: |
          AWS_VER_REGEXP_2='aws-cli\/2.\d*.\d*'
          AWS_VER_REGEXP_1='aws-cli\/1.\d*.\d*'
          # initialize installed version to zero, to signify not installed (Or we want to ignore the installed version and re-install).
          AWS_CLI_INSTALLED_VERSION="0"
          AWS_CLI_VERSION_SELECTED="2"

          if [[ $EUID == 0 ]]; then export SUDO=""; else export SUDO="sudo"; fi

          if [ "false" == "false" ]; then
              if ! command -v aws --version >/dev/null 2>&1  ; then
                  echo AWS is not installed
              else
                  echo AWS is currently installed.
                  if aws --version 2>&1 | grep -q $AWS_VER_REGEXP_2; then
                      echo AWS CLI v2 is installed
                      AWS_CLI_INSTALLED_VERSION="2"
                  fi
                  if aws --version 2>&1 | grep -q $AWS_VER_REGEXP_1; then
                      echo AWS CLI v1 is installed
                      AWS_CLI_INSTALLED_VERSION="1"
                  fi
              fi
          else
              echo "Skipping version check. Installing CLI"
          fi

          AWS_V2_UPDATE_PARAM=""
          if aws --version 2>&1 | grep -q $AWS_VER_REGEXP_2; then
              AWS_V2_UPDATE_PARAM="--update"
          fi

          #If the desired version of the CLI is not installed, install it.
          if [[ $AWS_CLI_VERSION_SELECTED != $AWS_CLI_INSTALLED_VERSION ]]; then

              #uninstall AWS CLI if it is installed.
              if which aws; then
                  echo Uninstalling old CLI
                  $SUDO rm -rf $(which aws)
              fi
              case $AWS_CLI_VERSION_SELECTED in
                  "1")
                      if ! command -v python >/dev/null 2>&1 && ! command -v python3 >/dev/null 2>&1 ; then
                          echo "Your environment does not seem to have Python installed, a requirement of the AWS CLI."
                          echo "Please either utilize the AWS CLI v2, or select an envionment with Python installed."
                          echo "Recommended image: cimg:/python:3.8"
                          exit 1
                      fi
                      # install CLI v1
                      export PIP=$(which pip pip3 | head -1)
                      if [[ -n $PIP ]]; then
                          if which sudo > /dev/null; then
                              sudo $PIP install awscli --upgrade
                          else
                              # This installs the AWS CLI to ~/.local/bin. Make sure that ~/.local/bin is in your $PATH.
                              $PIP install awscli --upgrade --user
                          fi
                      elif [[ $(which unzip curl | wc -l) -eq 2 ]]; then
                          cd
                          curl "https://s3.amazonaws.com/aws-cli/awscli-bundle.zip" -o "awscli-bundle.zip"
                          unzip awscli-bundle.zip
                          if which sudo > /dev/null; then
                              sudo ~/awscli-bundle/install -i /usr/local/aws -b /usr/local/bin/aws
                          else
                              # This installs the AWS CLI to the default location (~/.local/lib/aws) and create a symbolic link (symlink) at ~/bin/aws. Make sure that ~/bin is in your $PATH.
                              awscli-bundle/install -b ~/bin/aws
                          fi
                          rm -rf awscli-bundle*
                          cd -
                      else
                          echo "Unable to install AWS CLI. Please install pip."
                          exit 1
                      fi
                      # Installation check
                      if aws --version &> grep -q "aws-cli/1"; then
                          echo "AWS CLI V1 has been installed successfully"
                          exit 0
                      else
                          echo "There was an issue installing the AWS CLI V1. Exiting."
                          exit 1
                      fi
                  ;;
                  "2")
                      # install CLI v2

                      cd /tmp || exit

                      # PLATFORM CHECK: mac vs. alpine vs. other linux
                      if uname -a | grep Darwin; then
                          SYS_ENV_PLATFORM=darwin
                      elif uname -a | grep Linux; then
                          SYS_ENV_PLATFORM=linux
                      else
                          echo "This platform appears to be unsupported."
                          uname -a
                          exit 1
                      fi

                      case $SYS_ENV_PLATFORM in
                          linux)
                              curl -sSL "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
                              unzip awscliv2.zip
                              $SUDO ./aws/install $AWS_V2_UPDATE_PARAM
                              rm awscliv2.zip
                              ;;
                          darwin)
                              curl -sSL "https://awscli.amazonaws.com/AWSCLIV2.pkg" -o "AWSCLIV2.pkg"
                              $SUDO installer -pkg AWSCLIV2.pkg -target /
                              rm AWSCLIV2.pkg
                              ;;
                          *)
                              echo "This orb does not currently support your platform. If you believe it should, please consider opening an issue on the GitHub repository:"
                              echo "https://github.com/CircleCI-Public/aws-cli-orb/issues/new"
                              exit 1
                          ;;
                      esac
                      # Installation check
                      if aws --version &> grep -q "aws-cli/2"; then
                          echo "AWS CLI V2 has been installed successfully"
                          exit 0
                      else
                          echo "There was an issue installing the AWS CLI V2. Exiting."
                          exit 1
                      fi
                  ;;
              esac

          else
              echo "The v${AWS_CLI_VERSION_SELECTED} AWS CLI is already installed."
              exit 0
          fi
        name: Install AWS CLI v2
    - run:
        command: |
          if [ -z "${AWS_PAGER}" ]; then
            echo 'export AWS_PAGER=""' >> $BASH_ENV
            echo "AWS_PAGER is being set to the empty string to disable all output paging for AWS CLI commands."
            echo "You can set the 'disable-aws-pager' parameter to 'false' to disable this behavior."
          fi
        name: Disable AWS pager if not already configured
    - run:
        command: |
          aws configure set aws_access_key_id \
            $AWS_ACCESS_KEY_ID \
            --profile default
        name: Configure AWS Access Key ID
    - run:
        command: |
          aws configure set aws_secret_access_key \
            $AWS_SECRET_ACCESS_KEY \
            --profile default
        name: Configure AWS Secret Access Key
    - run:
        command: |
          aws configure set default.region $AWS_REGION \
            --profile default
        name: Configure AWS default region
    - run:
        command: |
          # get-login-password returns a password that we pipe to the docker login command
          aws ecr get-login-password --region $AWS_REGION --profile default | docker login --username AWS --password-stdin $AWS_ECR_ACCOUNT_URL
        name: Log into Amazon ECR
    - run:
        command: |
          registry_id=$(echo $AWS_ECR_ACCOUNT_URL | sed "s;\..*;;g")
          number_of_tags_in_ecr=0

          docker_tag_args=""
          IFS="," read -ra DOCKER_TAGS <<< "${CIRCLE_SHA1}"
          for tag in "${DOCKER_TAGS[@]}"; do
            if [ "false" = "true" ]; then
              docker_tag_exists_in_ecr=$(aws ecr describe-images --registry-id $registry_id --repository-name dev-assettracker-api-microservice --query "contains(imageDetails[].imageTags[], '$tag')")
              if [ "$docker_tag_exists_in_ecr" = "true" ]; then
                docker pull $AWS_ECR_ACCOUNT_URL/dev-assettracker-api-microservice:${tag}
                let "number_of_tags_in_ecr+=1"
              fi
            fi
            docker_tag_args="$docker_tag_args -t $AWS_ECR_ACCOUNT_URL/dev-assettracker-api-microservice:$tag"
          done
          if [ "false" = "false" ] || [ "false" = "true" -a $number_of_tags_in_ecr -lt ${#DOCKER_TAGS[@]} ]; then
            docker build \
               \
              -f ./Dockerfile \
              $docker_tag_args \
              .
          fi
        name: Build docker image
        no_output_timeout: 10m
    - run:
        command: |
          IFS="," read -ra DOCKER_TAGS <<< "${CIRCLE_SHA1}"
          for tag in "${DOCKER_TAGS[@]}"; do
            docker push $AWS_ECR_ACCOUNT_URL/dev-assettracker-api-microservice:${tag}
          done
        name: Push image to Amazon ECR
  aws-ecs/deploy-service-update-staging:
    docker:
    - image: circleci/python:3.7.1
    steps:
    - run:
        name: Install AWS CLI
        command: |
          export PIP=$(which pip pip3 | head -1)
          if [[ -n $PIP ]]; then
            if which sudo > /dev/null; then
              sudo $PIP install awscli --upgrade
            else
              # This installs the AWS CLI to ~/.local/bin. Make sure that ~/.local/bin is in your $PATH.
              $PIP install aws --upgrade --user
            fi
          elif [[ $(which unzip curl | wc -l) -eq 2 ]]; then
            cd
            curl "https://s3.amazonaws.com/aws-cli/awscli-bundle.zip" -o "awscli-bundle.zip"
            unzip awscli-bundle.zip
            if which sudo > /dev/null; then
              sudo ~/awscli-bundle/install -i /usr/local/aws -b /usr/local/bin/aws
            else
              # This installs the AWS CLI to the default location (~/.local/lib/aws) and create a symbolic link (symlink) at ~/bin/aws. Make sure that ~/bin is in your $PATH.
              awscli-bundle/install -b ~/bin/aws
            fi
            rm -rf awscli-bundle*
            cd -
          else
            echo "Unable to install AWS CLI. Please install pip."
            exit 1
          fi
    - run:
        name: Configure AWS Access Key ID
        command: |
          aws configure set aws_access_key_id \
          $AWS_ACCESS_KEY_ID \
          --profile default
    - run:
        name: Configure AWS Secret Access Key
        command: |
          aws configure set aws_secret_access_key \
          $AWS_SECRET_ACCESS_KEY \
          --profile default
    - run:
        name: Configure AWS default region
        command: |
          aws configure set region $AWS_REGION \
          --profile default
    - run:
        name: Retrieve previous task definition and prepare new task definition values
        command: |
          set -o noglob
          PREVIOUS_TASK_DEFINITION=$(aws ecs describe-task-definition --task-definition staging-assettracker-api-microservice --include TAGS)
          CONTAINER_IMAGE_NAME_UPDATES="$(echo container=staging-assettracker-api-microservice,tag=${CIRCLE_SHA1})"
          CONTAINER_ENV_VAR_UPDATES="$(echo )"

          # Prepare script for updating container definitions
          UPDATE_CONTAINER_DEFS_SCRIPT_FILE=$(mktemp _update_container_defs.py.XXXXXX)
          chmod +x $UPDATE_CONTAINER_DEFS_SCRIPT_FILE
          cat > $UPDATE_CONTAINER_DEFS_SCRIPT_FILE <<-EOF
          from __future__ import absolute_import
          import sys
          import json


          def run(previous_task_definition, container_image_name_updates, container_env_var_updates):
              try:
                  definition = json.loads(previous_task_definition)
                  container_definitions = definition['taskDefinition']['containerDefinitions']
              except:
                  raise Exception('No valid task definition found: ' +
                                  previous_task_definition)

              # Build a map of the original container definitions so that the
              # array index positions can be easily looked up
              container_map = {}
              for index, container_definition in enumerate(container_definitions):
                  env_var_map = {}
                  env_var_definitions = container_definition.get('environment')
                  if env_var_definitions is not None:
                      for env_var_index, env_var_definition in enumerate(env_var_definitions):
                          env_var_map[env_var_definition['name']] = {
                              'index': env_var_index}
                  container_map[container_definition['name']] = {
                      'image': container_definition['image'], 'index': index, 'environment_map': env_var_map}

              # Expected format: container=...,name=...,value=...,container=...,name=...,value=
              try:
                  env_kv_pairs = container_env_var_updates.split(',')
                  for index, kv_pair in enumerate(env_kv_pairs):
                      kv = kv_pair.split('=')
                      key = kv[0].strip()

                      if key == 'container':
                          container_name = kv[1].strip()
                          env_var_name_kv = env_kv_pairs[index+1].split('=')
                          env_var_name = env_var_name_kv[1].strip()
                          env_var_value_kv = env_kv_pairs[index+2].split('=')
                          env_var_value = env_var_value_kv[1].strip()
                          if env_var_name_kv[0].strip() != 'name' or env_var_value_kv[0].strip() != 'value':
                              raise ValueError(
                                  'Environment variable update parameter format is incorrect: ' + container_env_var_updates)

                          container_entry = container_map.get(container_name)
                          if container_entry is None:
                              raise ValueError('The container ' + container_name +
                                               ' is not defined in the existing task definition')
                          container_index = container_entry['index']
                          env_var_entry = container_entry['environment_map'].get(
                              env_var_name)
                          if env_var_entry is None:
                              # The existing container definition did not contain environment variables
                              if container_definitions[container_index].get('environment') is None:
                                  container_definitions[container_index]['environment'] = []
                              # This env var did not exist in the existing container definition
                              container_definitions[container_index]['environment'].append({'name': env_var_name, 'value': env_var_value})
                          else:
                              env_var_index = env_var_entry['index']
                              container_definitions[container_index]['environment'][env_var_index]['value'] = env_var_value
                      elif key and key not in ['container', 'name', 'value']:
                          raise ValueError(
                              'Incorrect key found in environment variable update parameter: ' + key)
              except ValueError as value_error:
                  raise value_error
              except:
                  raise Exception(
                      'Environment variable update parameter could not be processed; please check parameter value: ' + container_env_var_updates)

              # Expected format: container=...,image-and-tag|image|tag=...,container=...,image-and-tag|image|tag=...,
              try:
                  if container_image_name_updates and "container=" not in container_image_name_updates:
                      raise ValueError(
                          'The container parameter is required in the container_image_name_updates variable.')

                  image_kv_pairs = container_image_name_updates.split(',')
                  for index, kv_pair in enumerate(image_kv_pairs):
                      kv = kv_pair.split('=')
                      key = kv[0].strip()
                      if key == 'container':
                          container_name = kv[1].strip()
                          image_kv = image_kv_pairs[index+1].split('=')
                          container_entry = container_map.get(container_name)
                          if container_entry is None:
                              raise ValueError('The container ' + container_name +
                                               ' is not defined in the existing task definition')
                          container_index = container_entry['index']
                          image_specifier_type = image_kv[0].strip()
                          image_value = image_kv[1].strip()
                          if image_specifier_type == 'image-and-tag':
                              container_definitions[container_index]['image'] = image_value
                          else:
                              existing_image_name_tokens = container_entry['image'].split(
                                  ':')
                              if image_specifier_type == 'image':
                                  tag = ''
                                  if len(existing_image_name_tokens) == 2:
                                      tag = ':' + existing_image_name_tokens[1]
                                  container_definitions[container_index]['image'] = image_value + tag
                              elif image_specifier_type == 'tag':
                                  container_definitions[container_index]['image'] = existing_image_name_tokens[0] + \
                                      ':' + image_value
                              else:
                                  raise ValueError(
                                      'Image name update parameter format is incorrect: ' + container_image_name_updates)
                      elif key and key not in ['container', 'image', 'image-and-tag', 'tag']:
                          raise ValueError(
                              'Incorrect key found in image name update parameter: ' + key)

              except ValueError as value_error:
                  raise value_error
              except:
                  raise Exception(
                      'Image name update parameter could not be processed; please check parameter value: ' + container_image_name_updates)
              return json.dumps(container_definitions)


          if __name__ == '__main__':
              try:
                  print(run(sys.argv[1], sys.argv[2], sys.argv[3]))
              except Exception as e:
                  sys.stderr.write(str(e) + "\n")
                  exit(1)

          EOF

          # Prepare container definitions
          CONTAINER_DEFS=$(python $UPDATE_CONTAINER_DEFS_SCRIPT_FILE "$PREVIOUS_TASK_DEFINITION" "$CONTAINER_IMAGE_NAME_UPDATES" "$CONTAINER_ENV_VAR_UPDATES")

          # Escape single quotes from environment variables for BASH_ENV
          CLEANED_CONTAINER_DEFS=$(echo "$CONTAINER_DEFS" | sed -E "s:':'\\\'':g")

          # Prepare script for getting task definition values
          GET_TASK_DFN_VAL_SCRIPT_FILE=$(mktemp _get_task_def_value.py.XXXXXX)
          chmod +x $GET_TASK_DFN_VAL_SCRIPT_FILE
          cat > $GET_TASK_DFN_VAL_SCRIPT_FILE <<-EOF
          from __future__ import absolute_import
          import sys
          import json


          def run(element_name, task_definition_str):
              try:
                  definition = json.loads(task_definition_str)
                  task_definition = definition['taskDefinition']
              except:
                  raise Exception('No valid task definition found: ' +
                                  task_definition_str)
              str_list_types = ['requiresCompatibilities']
              json_arr_types = ['placementConstraints', 'volumes', 'tags']
              json_obj_types = ['proxyConfiguration']
              if element_name in json_arr_types:
                  output_value = '[]'
              elif element_name in json_obj_types:
                  output_value = '{}'
              else:
                  output_value = ''
              if element_name == 'tags':
                  if element_name in definition:
                      element_value = definition[element_name]
                      output_value = json.dumps(element_value)
              elif element_name in task_definition:
                  element_value = task_definition[element_name]
                  if element_name in str_list_types:
                      output_value = ' '.join(list_item.strip() for list_item in element_value)
                  elif element_name in json_arr_types or element_name in json_obj_types:
                      output_value = json.dumps(element_value)
                  else:
                      output_value = str(element_value)
              return output_value


          if __name__ == '__main__':
              try:
                  print(run(sys.argv[1], sys.argv[2]))
              except Exception as e:
                  sys.stderr.write(str(e) + "\n")
                  exit(1)

          EOF

          # Get other task definition values
          TASK_ROLE=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'taskRoleArn' "$PREVIOUS_TASK_DEFINITION")
          EXECUTION_ROLE=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'executionRoleArn' "$PREVIOUS_TASK_DEFINITION")
          NETWORK_MODE=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'networkMode' "$PREVIOUS_TASK_DEFINITION")
          VOLUMES=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'volumes' "$PREVIOUS_TASK_DEFINITION")
          PLACEMENT_CONSTRAINTS=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'placementConstraints' "$PREVIOUS_TASK_DEFINITION")
          REQ_COMP=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'requiresCompatibilities' "$PREVIOUS_TASK_DEFINITION")
          TASK_CPU=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'cpu' "$PREVIOUS_TASK_DEFINITION")
          TASK_MEMORY=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'memory' "$PREVIOUS_TASK_DEFINITION")
          PID_MODE=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'pidMode' "$PREVIOUS_TASK_DEFINITION")
          IPC_MODE=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'ipcMode' "$PREVIOUS_TASK_DEFINITION")
          TAGS=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'tags' "$PREVIOUS_TASK_DEFINITION")
          PROXY_CONFIGURATION=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'proxyConfiguration' "$PREVIOUS_TASK_DEFINITION")

          # Make task definition values available as env variables
          echo "export CCI_ORB_AWS_ECS_TASK_ROLE='${TASK_ROLE}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_EXECUTION_ROLE='${EXECUTION_ROLE}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_NETWORK_MODE='${NETWORK_MODE}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_CONTAINER_DEFS='${CLEANED_CONTAINER_DEFS}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_VOLUMES='${VOLUMES}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_PLACEMENT_CONSTRAINTS='${PLACEMENT_CONSTRAINTS}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_REQ_COMP='${REQ_COMP}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_TASK_CPU='${TASK_CPU}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_TASK_MEMORY='${TASK_MEMORY}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_PID_MODE='${PID_MODE}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_IPC_MODE='${IPC_MODE}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_TAGS='${TAGS}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_PROXY_CONFIGURATION='${PROXY_CONFIGURATION}'" >> $BASH_ENV

          rm $UPDATE_CONTAINER_DEFS_SCRIPT_FILE $GET_TASK_DFN_VAL_SCRIPT_FILE
    - run:
        name: Register new task definition
        command: |
          set -o noglob
          if [ -n "${CCI_ORB_AWS_ECS_TASK_ROLE}" ]; then
              set -- "$@" --task-role-arn "${CCI_ORB_AWS_ECS_TASK_ROLE}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_EXECUTION_ROLE}" ]; then
              set -- "$@" --execution-role-arn "${CCI_ORB_AWS_ECS_EXECUTION_ROLE}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_NETWORK_MODE}" ]; then
              set -- "$@" --network-mode "${CCI_ORB_AWS_ECS_NETWORK_MODE}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_VOLUMES}" ] && [ "${CCI_ORB_AWS_ECS_VOLUMES}" != "[]" ]; then
              set -- "$@" --volumes "${CCI_ORB_AWS_ECS_VOLUMES}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_PLACEMENT_CONSTRAINTS}" ] && [ "${CCI_ORB_AWS_ECS_PLACEMENT_CONSTRAINTS}" != "[]" ]; then
              set -- "$@" --placement-constraints "${CCI_ORB_AWS_ECS_PLACEMENT_CONSTRAINTS}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_REQ_COMP}" ] && [ "${CCI_ORB_AWS_ECS_REQ_COMP}" != "[]" ]; then
              set -- "$@" --requires-compatibilities ${CCI_ORB_AWS_ECS_REQ_COMP}
          fi
          if [ -n "${CCI_ORB_AWS_ECS_TASK_CPU}" ]; then
              set -- "$@" --cpu "${CCI_ORB_AWS_ECS_TASK_CPU}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_TASK_MEMORY}" ]; then
              set -- "$@" --memory "${CCI_ORB_AWS_ECS_TASK_MEMORY}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_PID_MODE}" ]; then
              set -- "$@" --pid-mode "${CCI_ORB_AWS_ECS_PID_MODE}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_IPC_MODE}" ]; then
              set -- "$@" --ipc-mode "${CCI_ORB_AWS_ECS_IPC_MODE}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_TAGS}" ] && [ "${CCI_ORB_AWS_ECS_TAGS}" != "[]" ]; then
              set -- "$@" --tags "${CCI_ORB_AWS_ECS_TAGS}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_PROXY_CONFIGURATION}" ] && [ "${CCI_ORB_AWS_ECS_PROXY_CONFIGURATION}" != "{}" ]; then
              set -- "$@" --proxy-configuration "${CCI_ORB_AWS_ECS_PROXY_CONFIGURATION}"
          fi
          REVISION=$(aws ecs register-task-definition \
              --family staging-assettracker-api-microservice \
              --container-definitions "${CCI_ORB_AWS_ECS_CONTAINER_DEFS}" \
              "$@" \
              --output text \
              --query 'taskDefinition.taskDefinitionArn')
          echo "Registered task definition: ${REVISION}"
          echo "export CCI_ORB_AWS_ECS_REGISTERED_TASK_DFN='${REVISION}'" >> $BASH_ENV
    - run:
        name: Update service with registered task definition
        command: |
          set -o noglob
          SERVICE_NAME="$(echo staging-assettracker-api-microservice)"

          if [ -z "${SERVICE_NAME}" ]; then
              SERVICE_NAME="$(echo staging-assettracker-api-microservice)"
          fi
          if [ "false" == "true" ]; then
              set -- "$@" --force-new-deployment
          fi
          DEPLOYED_REVISION=$(aws ecs update-service \
              --cluster "staging-assettracker-api-microservice" \
              --service "${SERVICE_NAME}" \
              --task-definition "${CCI_ORB_AWS_ECS_REGISTERED_TASK_DFN}" \
              --output text \
              --query service.taskDefinition \
              "$@")
          echo "export CCI_ORB_AWS_ECS_DEPLOYED_REVISION='${DEPLOYED_REVISION}'" >> $BASH_ENV
  deployment-dev-build-notify:
    docker:
    - image: cimg/node:14.15.1-browsers
    steps:
    - run:
        name: Prepare Template
        when: always
        command: |
          SHORT_SHA1=`echo -n $CIRCLE_SHA1 | head -c 7`

          if [ `echo "$CIRCLE_REPOSITORY_URL" | grep "^git@github.com"` ]; then
            COMMIT_LINK=\[$SHORT_SHA1\]\(https://github.com/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/commit/$CIRCLE_SHA1\)
          elif [ `echo "$CIRCLE_REPOSITORY_URL" | grep "^git@bitbucket.org"` ]; then
            COMMIT_LINK=\[$SHORT_SHA1\]\(https://bitbucket.org/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/commit/$CIRCLE_SHA1\)
          else
            >&2 echo unknown version control system: $CIRCLE_REPOSITORY_URL
            fail
          fi

          # Note that the "<<" in the heredoc declaration is escaped from
          # CircleCI's parameters syntax.
          MS_TEAMS_MSG_TEMPLATE=$(cat <<END_HEREDOC
          {
            "@type": "MessageCard",
            "@context": "http://schema.org/extensions",
            "themeCdocker_jobolor": "__theme_color__",
            "summary": "CircleCI Build Notification",
            "sections": [
              {
                "activityTitle": "__build_status__: $CIRCLE_PROJECT_REPONAME job [${CIRCLE_JOB} #${CIRCLE_BUILD_NUM}]($CIRCLE_BUILD_URL)",
                "facts": [
                  {
                    "name": "Git ref",
                    "value": "$CIRCLE_BRANCH $CIRCLE_TAG"
                  },
                  {
                    "name": "Commit",
                    "value": "$COMMIT_LINK"
                  }
                ],
                "markdown": true
              }
            ]
          }
          END_HEREDOC
          )
          echo "$MS_TEAMS_MSG_TEMPLATE" > /tmp/ms_teams_message
    - run:
        name: Report Build Success
        command: |
          MSG_PATH=/tmp/ms_teams_success_message
          sed -e 's/__build_status__/Success/' -e 's/__theme_color__/14a603/' \
              /tmp/ms_teams_message > $MSG_PATH
          curl --fail -H "Content-Type: application/json" \
                --data-binary @$MSG_PATH \
                https://eldmandate.webhook.office.com/webhookb2/37002470-5070-4f01-b6ed-3bcc44180824@6a4f939d-635f-454d-9d19-7926a1208c06/IncomingWebhook/aae189ec52a04f04bd7d2c6e8271461d/aea37b94-7ffa-42b8-9cbe-014d0a48e677
        when: on_success
    - run:
        name: Report Build Failure
        command: |
          MSG_PATH=/tmp/ms_teams_failure_message
          sed -e 's/__build_status__/Failed/' -e 's/__theme_color__/e2091d/' \
              /tmp/ms_teams_message > $MSG_PATH
          curl --fail -H "Content-Type: application/json" \
                --data-binary @$MSG_PATH \
                https://eldmandate.webhook.office.com/webhookb2/37002470-5070-4f01-b6ed-3bcc44180824@6a4f939d-635f-454d-9d19-7926a1208c06/IncomingWebhook/aae189ec52a04f04bd7d2c6e8271461d/aea37b94-7ffa-42b8-9cbe-014d0a48e677
        when: on_fail
  aws-ecs/deploy-service-update-dev:
    docker:
    - image: circleci/python:3.7.1
    steps:
    - run:
        name: Install AWS CLI
        command: |
          export PIP=$(which pip pip3 | head -1)
          if [[ -n $PIP ]]; then
            if which sudo > /dev/null; then
              sudo $PIP install awscli --upgrade
            else
              # This installs the AWS CLI to ~/.local/bin. Make sure that ~/.local/bin is in your $PATH.
              $PIP install aws --upgrade --user
            fi
          elif [[ $(which unzip curl | wc -l) -eq 2 ]]; then
            cd
            curl "https://s3.amazonaws.com/aws-cli/awscli-bundle.zip" -o "awscli-bundle.zip"
            unzip awscli-bundle.zip
            if which sudo > /dev/null; then
              sudo ~/awscli-bundle/install -i /usr/local/aws -b /usr/local/bin/aws
            else
              # This installs the AWS CLI to the default location (~/.local/lib/aws) and create a symbolic link (symlink) at ~/bin/aws. Make sure that ~/bin is in your $PATH.
              awscli-bundle/install -b ~/bin/aws
            fi
            rm -rf awscli-bundle*
            cd -
          else
            echo "Unable to install AWS CLI. Please install pip."
            exit 1
          fi
    - run:
        name: Configure AWS Access Key ID
        command: |
          aws configure set aws_access_key_id \
          $AWS_ACCESS_KEY_ID \
          --profile default
    - run:
        name: Configure AWS Secret Access Key
        command: |
          aws configure set aws_secret_access_key \
          $AWS_SECRET_ACCESS_KEY \
          --profile default
    - run:
        name: Configure AWS default region
        command: |
          aws configure set region $AWS_REGION \
          --profile default
    - run:
        name: Retrieve previous task definition and prepare new task definition values
        command: |
          set -o noglob
          PREVIOUS_TASK_DEFINITION=$(aws ecs describe-task-definition --task-definition dev-assettracker-api-microservice --include TAGS)
          CONTAINER_IMAGE_NAME_UPDATES="$(echo container=dev-assettracker-api-microservice,tag=${CIRCLE_SHA1})"
          CONTAINER_ENV_VAR_UPDATES="$(echo )"

          # Prepare script for updating container definitions
          UPDATE_CONTAINER_DEFS_SCRIPT_FILE=$(mktemp _update_container_defs.py.XXXXXX)
          chmod +x $UPDATE_CONTAINER_DEFS_SCRIPT_FILE
          cat > $UPDATE_CONTAINER_DEFS_SCRIPT_FILE <<-EOF
          from __future__ import absolute_import
          import sys
          import json


          def run(previous_task_definition, container_image_name_updates, container_env_var_updates):
              try:
                  definition = json.loads(previous_task_definition)
                  container_definitions = definition['taskDefinition']['containerDefinitions']
              except:
                  raise Exception('No valid task definition found: ' +
                                  previous_task_definition)

              # Build a map of the original container definitions so that the
              # array index positions can be easily looked up
              container_map = {}
              for index, container_definition in enumerate(container_definitions):
                  env_var_map = {}
                  env_var_definitions = container_definition.get('environment')
                  if env_var_definitions is not None:
                      for env_var_index, env_var_definition in enumerate(env_var_definitions):
                          env_var_map[env_var_definition['name']] = {
                              'index': env_var_index}
                  container_map[container_definition['name']] = {
                      'image': container_definition['image'], 'index': index, 'environment_map': env_var_map}

              # Expected format: container=...,name=...,value=...,container=...,name=...,value=
              try:
                  env_kv_pairs = container_env_var_updates.split(',')
                  for index, kv_pair in enumerate(env_kv_pairs):
                      kv = kv_pair.split('=')
                      key = kv[0].strip()

                      if key == 'container':
                          container_name = kv[1].strip()
                          env_var_name_kv = env_kv_pairs[index+1].split('=')
                          env_var_name = env_var_name_kv[1].strip()
                          env_var_value_kv = env_kv_pairs[index+2].split('=')
                          env_var_value = env_var_value_kv[1].strip()
                          if env_var_name_kv[0].strip() != 'name' or env_var_value_kv[0].strip() != 'value':
                              raise ValueError(
                                  'Environment variable update parameter format is incorrect: ' + container_env_var_updates)

                          container_entry = container_map.get(container_name)
                          if container_entry is None:
                              raise ValueError('The container ' + container_name +
                                               ' is not defined in the existing task definition')
                          container_index = container_entry['index']
                          env_var_entry = container_entry['environment_map'].get(
                              env_var_name)
                          if env_var_entry is None:
                              # The existing container definition did not contain environment variables
                              if container_definitions[container_index].get('environment') is None:
                                  container_definitions[container_index]['environment'] = []
                              # This env var did not exist in the existing container definition
                              container_definitions[container_index]['environment'].append({'name': env_var_name, 'value': env_var_value})
                          else:
                              env_var_index = env_var_entry['index']
                              container_definitions[container_index]['environment'][env_var_index]['value'] = env_var_value
                      elif key and key not in ['container', 'name', 'value']:
                          raise ValueError(
                              'Incorrect key found in environment variable update parameter: ' + key)
              except ValueError as value_error:
                  raise value_error
              except:
                  raise Exception(
                      'Environment variable update parameter could not be processed; please check parameter value: ' + container_env_var_updates)

              # Expected format: container=...,image-and-tag|image|tag=...,container=...,image-and-tag|image|tag=...,
              try:
                  if container_image_name_updates and "container=" not in container_image_name_updates:
                      raise ValueError(
                          'The container parameter is required in the container_image_name_updates variable.')

                  image_kv_pairs = container_image_name_updates.split(',')
                  for index, kv_pair in enumerate(image_kv_pairs):
                      kv = kv_pair.split('=')
                      key = kv[0].strip()
                      if key == 'container':
                          container_name = kv[1].strip()
                          image_kv = image_kv_pairs[index+1].split('=')
                          container_entry = container_map.get(container_name)
                          if container_entry is None:
                              raise ValueError('The container ' + container_name +
                                               ' is not defined in the existing task definition')
                          container_index = container_entry['index']
                          image_specifier_type = image_kv[0].strip()
                          image_value = image_kv[1].strip()
                          if image_specifier_type == 'image-and-tag':
                              container_definitions[container_index]['image'] = image_value
                          else:
                              existing_image_name_tokens = container_entry['image'].split(
                                  ':')
                              if image_specifier_type == 'image':
                                  tag = ''
                                  if len(existing_image_name_tokens) == 2:
                                      tag = ':' + existing_image_name_tokens[1]
                                  container_definitions[container_index]['image'] = image_value + tag
                              elif image_specifier_type == 'tag':
                                  container_definitions[container_index]['image'] = existing_image_name_tokens[0] + \
                                      ':' + image_value
                              else:
                                  raise ValueError(
                                      'Image name update parameter format is incorrect: ' + container_image_name_updates)
                      elif key and key not in ['container', 'image', 'image-and-tag', 'tag']:
                          raise ValueError(
                              'Incorrect key found in image name update parameter: ' + key)

              except ValueError as value_error:
                  raise value_error
              except:
                  raise Exception(
                      'Image name update parameter could not be processed; please check parameter value: ' + container_image_name_updates)
              return json.dumps(container_definitions)


          if __name__ == '__main__':
              try:
                  print(run(sys.argv[1], sys.argv[2], sys.argv[3]))
              except Exception as e:
                  sys.stderr.write(str(e) + "\n")
                  exit(1)

          EOF

          # Prepare container definitions
          CONTAINER_DEFS=$(python $UPDATE_CONTAINER_DEFS_SCRIPT_FILE "$PREVIOUS_TASK_DEFINITION" "$CONTAINER_IMAGE_NAME_UPDATES" "$CONTAINER_ENV_VAR_UPDATES")

          # Escape single quotes from environment variables for BASH_ENV
          CLEANED_CONTAINER_DEFS=$(echo "$CONTAINER_DEFS" | sed -E "s:':'\\\'':g")

          # Prepare script for getting task definition values
          GET_TASK_DFN_VAL_SCRIPT_FILE=$(mktemp _get_task_def_value.py.XXXXXX)
          chmod +x $GET_TASK_DFN_VAL_SCRIPT_FILE
          cat > $GET_TASK_DFN_VAL_SCRIPT_FILE <<-EOF
          from __future__ import absolute_import
          import sys
          import json


          def run(element_name, task_definition_str):
              try:
                  definition = json.loads(task_definition_str)
                  task_definition = definition['taskDefinition']
              except:
                  raise Exception('No valid task definition found: ' +
                                  task_definition_str)
              str_list_types = ['requiresCompatibilities']
              json_arr_types = ['placementConstraints', 'volumes', 'tags']
              json_obj_types = ['proxyConfiguration']
              if element_name in json_arr_types:
                  output_value = '[]'
              elif element_name in json_obj_types:
                  output_value = '{}'
              else:
                  output_value = ''
              if element_name == 'tags':
                  if element_name in definition:
                      element_value = definition[element_name]
                      output_value = json.dumps(element_value)
              elif element_name in task_definition:
                  element_value = task_definition[element_name]
                  if element_name in str_list_types:
                      output_value = ' '.join(list_item.strip() for list_item in element_value)
                  elif element_name in json_arr_types or element_name in json_obj_types:
                      output_value = json.dumps(element_value)
                  else:
                      output_value = str(element_value)
              return output_value


          if __name__ == '__main__':
              try:
                  print(run(sys.argv[1], sys.argv[2]))
              except Exception as e:
                  sys.stderr.write(str(e) + "\n")
                  exit(1)

          EOF

          # Get other task definition values
          TASK_ROLE=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'taskRoleArn' "$PREVIOUS_TASK_DEFINITION")
          EXECUTION_ROLE=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'executionRoleArn' "$PREVIOUS_TASK_DEFINITION")
          NETWORK_MODE=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'networkMode' "$PREVIOUS_TASK_DEFINITION")
          VOLUMES=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'volumes' "$PREVIOUS_TASK_DEFINITION")
          PLACEMENT_CONSTRAINTS=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'placementConstraints' "$PREVIOUS_TASK_DEFINITION")
          REQ_COMP=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'requiresCompatibilities' "$PREVIOUS_TASK_DEFINITION")
          TASK_CPU=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'cpu' "$PREVIOUS_TASK_DEFINITION")
          TASK_MEMORY=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'memory' "$PREVIOUS_TASK_DEFINITION")
          PID_MODE=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'pidMode' "$PREVIOUS_TASK_DEFINITION")
          IPC_MODE=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'ipcMode' "$PREVIOUS_TASK_DEFINITION")
          TAGS=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'tags' "$PREVIOUS_TASK_DEFINITION")
          PROXY_CONFIGURATION=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'proxyConfiguration' "$PREVIOUS_TASK_DEFINITION")

          # Make task definition values available as env variables
          echo "export CCI_ORB_AWS_ECS_TASK_ROLE='${TASK_ROLE}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_EXECUTION_ROLE='${EXECUTION_ROLE}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_NETWORK_MODE='${NETWORK_MODE}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_CONTAINER_DEFS='${CLEANED_CONTAINER_DEFS}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_VOLUMES='${VOLUMES}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_PLACEMENT_CONSTRAINTS='${PLACEMENT_CONSTRAINTS}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_REQ_COMP='${REQ_COMP}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_TASK_CPU='${TASK_CPU}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_TASK_MEMORY='${TASK_MEMORY}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_PID_MODE='${PID_MODE}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_IPC_MODE='${IPC_MODE}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_TAGS='${TAGS}'" >> $BASH_ENV
          echo "export CCI_ORB_AWS_ECS_PROXY_CONFIGURATION='${PROXY_CONFIGURATION}'" >> $BASH_ENV

          rm $UPDATE_CONTAINER_DEFS_SCRIPT_FILE $GET_TASK_DFN_VAL_SCRIPT_FILE
    - run:
        name: Register new task definition
        command: |
          set -o noglob
          if [ -n "${CCI_ORB_AWS_ECS_TASK_ROLE}" ]; then
              set -- "$@" --task-role-arn "${CCI_ORB_AWS_ECS_TASK_ROLE}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_EXECUTION_ROLE}" ]; then
              set -- "$@" --execution-role-arn "${CCI_ORB_AWS_ECS_EXECUTION_ROLE}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_NETWORK_MODE}" ]; then
              set -- "$@" --network-mode "${CCI_ORB_AWS_ECS_NETWORK_MODE}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_VOLUMES}" ] && [ "${CCI_ORB_AWS_ECS_VOLUMES}" != "[]" ]; then
              set -- "$@" --volumes "${CCI_ORB_AWS_ECS_VOLUMES}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_PLACEMENT_CONSTRAINTS}" ] && [ "${CCI_ORB_AWS_ECS_PLACEMENT_CONSTRAINTS}" != "[]" ]; then
              set -- "$@" --placement-constraints "${CCI_ORB_AWS_ECS_PLACEMENT_CONSTRAINTS}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_REQ_COMP}" ] && [ "${CCI_ORB_AWS_ECS_REQ_COMP}" != "[]" ]; then
              set -- "$@" --requires-compatibilities ${CCI_ORB_AWS_ECS_REQ_COMP}
          fi
          if [ -n "${CCI_ORB_AWS_ECS_TASK_CPU}" ]; then
              set -- "$@" --cpu "${CCI_ORB_AWS_ECS_TASK_CPU}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_TASK_MEMORY}" ]; then
              set -- "$@" --memory "${CCI_ORB_AWS_ECS_TASK_MEMORY}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_PID_MODE}" ]; then
              set -- "$@" --pid-mode "${CCI_ORB_AWS_ECS_PID_MODE}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_IPC_MODE}" ]; then
              set -- "$@" --ipc-mode "${CCI_ORB_AWS_ECS_IPC_MODE}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_TAGS}" ] && [ "${CCI_ORB_AWS_ECS_TAGS}" != "[]" ]; then
              set -- "$@" --tags "${CCI_ORB_AWS_ECS_TAGS}"
          fi
          if [ -n "${CCI_ORB_AWS_ECS_PROXY_CONFIGURATION}" ] && [ "${CCI_ORB_AWS_ECS_PROXY_CONFIGURATION}" != "{}" ]; then
              set -- "$@" --proxy-configuration "${CCI_ORB_AWS_ECS_PROXY_CONFIGURATION}"
          fi
          REVISION=$(aws ecs register-task-definition \
              --family dev-assettracker-api-microservice \
              --container-definitions "${CCI_ORB_AWS_ECS_CONTAINER_DEFS}" \
              "$@" \
              --output text \
              --query 'taskDefinition.taskDefinitionArn')
          echo "Registered task definition: ${REVISION}"
          echo "export CCI_ORB_AWS_ECS_REGISTERED_TASK_DFN='${REVISION}'" >> $BASH_ENV
    - run:
        name: Update service with registered task definition
        command: |
          set -o noglob
          SERVICE_NAME="$(echo dev-assettracker-api-microservice)"

          if [ -z "${SERVICE_NAME}" ]; then
              SERVICE_NAME="$(echo dev-assettracker-api-microservice)"
          fi
          if [ "false" == "true" ]; then
              set -- "$@" --force-new-deployment
          fi
          DEPLOYED_REVISION=$(aws ecs update-service \
              --cluster "dev-assettracker-api-microservice" \
              --service "${SERVICE_NAME}" \
              --task-definition "${CCI_ORB_AWS_ECS_REGISTERED_TASK_DFN}" \
              --output text \
              --query service.taskDefinition \
              "$@")
          echo "export CCI_ORB_AWS_ECS_DEPLOYED_REVISION='${DEPLOYED_REVISION}'" >> $BASH_ENV
workflows:
  version: 2
  build-and-test:
    jobs:
    - build_and_test:
        filters:
          branches:
            ignore:
            - develop
            - master
            - staging
  build-and-deploy-dev:
    jobs:
    - build_and_push_dev:
        filters:
          branches:
            only: develop
    - aws-ecs/deploy-service-update-dev:
        filters:
          branches:
            only: develop
        requires:
        - build_and_push_dev
    - deployment-dev-build-notify:
        filters:
          branches:
            only: develop
        requires:
        - aws-ecs/deploy-service-update-dev
  build-and-deploy-staging:
    jobs:
    - build_and_push_staging:
        filters:
          branches:
            only: staging
    - aws-ecs/deploy-service-update-staging:
        filters:
          branches:
            only: staging
        requires:
        - build_and_push_staging
    - deployment-staging-build-notify:
        filters:
          branches:
            only: staging
        requires:
        - aws-ecs/deploy-service-update-staging
  build-and-deploy-prod:
    jobs:
    - build_and_push_prod:
        filters:
          branches:
            only: master
    - aws-ecs/deploy-service-update-prod:
        filters:
          branches:
            only: master
        requires:
        - build_and_push_prod
    - deployment-prod-build-notify:
        filters:
          branches:
            only: master
        requires:
        - aws-ecs/deploy-service-update-prod
